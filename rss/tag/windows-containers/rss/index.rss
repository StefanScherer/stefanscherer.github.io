<!DOCTYPE html>
<html><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>windows-containers - Stefan Scherer's Blog</title><description>Just my techie notes.</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>windows-containers - Stefan Scherer's Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 1.8</generator><lastBuildDate>Wed, 14 Feb 2018 23:30:31 GMT</lastBuildDate><atom:link href="http://localhost:2368/tag/windows-containers/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>How to find dependencies of containerized Windows apps</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Running applications in Windows containers keeps your server clean. The container image must contain all the dependencies that the application needs to run, for example all its DLL's. But sometimes it's hard to figure out why an application doesn't run in a container. Here's my way to find out what's&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/find-dependencies-in-windows-containers/</link><guid isPermaLink="false">5a84a3660f689f0001bafe61</guid><category>windows-containers</category><category>Docker</category><category>Hyper-V</category><category>process-monitor</category><category>sysinternals</category><dc:creator>Stefan Scherer</dc:creator><pubDate>Wed, 14 Feb 2018 23:01:47 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Running applications in Windows containers keeps your server clean. The container image must contain all the dependencies that the application needs to run, for example all its DLL's. But sometimes it's hard to figure out why an application doesn't run in a container. Here's my way to find out what's missing.&lt;/p&gt;
&lt;h1 id="processmonitor"&gt;Process Monitor&lt;/h1&gt;
&lt;p&gt;To find out what's going on in a Windows Container I often use the &lt;a href="https://sysinternals.com"&gt;Sysinternals&lt;/a&gt; Process Monitor. It can capture all major syscalls in Windows such as file activity, starting processes, registry and networking activity.&lt;/p&gt;
&lt;p&gt;But how can we use procmon to monitor inside a Windows container?&lt;/p&gt;
&lt;p&gt;Well, I heard today that you can run procmon from command line to start and stop capturing events. I tried &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/tree/master/procmon"&gt;running procmon in a Windows container&lt;/a&gt;, but it doesn't work correctly at the moment.&lt;/p&gt;
&lt;p&gt;So the next possibilty is to run procmon on the container host.&lt;/p&gt;
&lt;p&gt;On Windows 10 you only have Hyper-V containers. These are &amp;quot;black boxes&amp;quot; from your host operating system. The Process Monitor cannot look inside Hyper-V containers.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/02/procmon_windows10_hyperv_container.png" alt="procmon_windows10_hyperv_container"&gt;&lt;/p&gt;
&lt;p&gt;To investigate a Windows container we need the &amp;quot;normal&amp;quot; Windows containers without running in Hyper-V isolation. The best solution I came up with is to run a Windows Server 2016 VM and install Process Monitor inside that VM.&lt;/p&gt;
&lt;p&gt;When you run a Windows container you can see the container processes in the Task Manager of the Server 2016 VM. And Process Monitor can also see what these processes are doing. We have made some containers out of &amp;quot;glass&amp;quot; to look inside.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/02/procmon_windows_container_glass.png" alt="procmon_windows_container_glass"&gt;&lt;/p&gt;
&lt;h1 id="examplepostgresql"&gt;Example: PostgreSQL&lt;/h1&gt;
&lt;p&gt;Let's try this out and put the PostgreSQL database server into a Windows container.&lt;/p&gt;
&lt;p&gt;The following &lt;code&gt;Dockerfile&lt;/code&gt; downloads the ZIP file of PostgreSQL 10.2, extracts all files and removes the ZIP file again.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# escape=`
FROM microsoft/windowsservercore:10.0.14393.2007 AS download

SHELL [&amp;quot;powershell&amp;quot;, &amp;quot;-Command&amp;quot;, &amp;quot;$ErrorActionPreference = 'Stop'; $ProgressPreference = 'SilentlyContinue';&amp;quot;]

ENV PG_VERSION 10.2-1

RUN Invoke-WebRequest $('https://get.enterprisedb.com/postgresql/postgresql-{0}-windows-x64-binaries.zip' -f $env:PG_VERSION) -OutFile 'postgres.zip' -UseBasicParsing ; `
    Expand-Archive postgres.zip -DestinationPath C:\ ; `
    Remove-Item postgres.zip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now build and run a first container to try out the &lt;code&gt;postgres.exe&lt;/code&gt; inside the container.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t postgres .
docker run -it postgres cmd
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Navigate into &lt;code&gt;C:\pgsql\bin&lt;/code&gt; folder and run &lt;code&gt;postgres.exe -h&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/02/postgres-nooutput.png" alt="postgres no output"&gt;&lt;/p&gt;
&lt;p&gt;As you can see, nothing happens. No output. You just are back to the CMD prompt.&lt;/p&gt;
&lt;p&gt;Now it's time to install &lt;code&gt;procmon.exe&lt;/code&gt; on the container host and run it.&lt;/p&gt;
&lt;p&gt;Open a PowerShell terminal in your Windows Server 2016 VM and run&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;iwr -usebasicparsing https://live.sysinternals.com/procmon.exe -outfile procmon.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/02/install-procmon.png-shadow.png" alt="install procmon"&gt;&lt;/p&gt;
&lt;p&gt;Now run &lt;code&gt;procmon.exe&lt;/code&gt; and define a filter to see only file activity looking for DLL files and start capturing.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/02/procmon-filter.png-shadow.png" alt="define procmon filter"&gt;&lt;/p&gt;
&lt;p&gt;I have a prepared filter available for download: &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/raw/master/procmon/depends.PMF"&gt;depends.PMF&lt;/a&gt;&lt;br&gt;
Go to &lt;strong&gt;Filter&lt;/strong&gt;, then &lt;strong&gt;Organize Filters...&lt;/strong&gt; and then &lt;strong&gt;Import...&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Now in your container run &lt;code&gt;postgres.exe -h&lt;/code&gt; again.&lt;/p&gt;
&lt;p&gt;As you can see Process Monitor captures file access to &lt;code&gt;\Device\Harddisk\VolumeXX\psql\bin\&lt;/code&gt; which is a folder in your container.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/02/procmon-postgres.png-shadow.png" alt="procmon postgres capture"&gt;&lt;/p&gt;
&lt;p&gt;The interesting part is which DLL's cannot be found here. The &lt;code&gt;MSVCR120.dll&lt;/code&gt; is missing, the Visual Studio Runtime DLL's.&lt;/p&gt;
&lt;p&gt;For other applications you might have to look for config files or folders that are missing that stops your app from running in a Windows container.&lt;/p&gt;
&lt;p&gt;Let's append the missing runtime in the &lt;code&gt;Dockerfile&lt;/code&gt; with the next few lines:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RUN Invoke-WebRequest 'http://download.microsoft.com/download/0/5/6/056DCDA9-D667-4E27-8001-8A0C6971D6B1/vcredist_x64.exe' -OutFile vcredist_x64.exe ; `
    Start-Process vcredist_x64.exe -ArgumentList '/install', '/passive', '/norestart' -NoNewWindow -Wait ; `
    Remove-Item vcredist_x64.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Build the image and run another container and see if it works now.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/02/postgres-usage.png" alt="postgres usage"&gt;&lt;/p&gt;
&lt;p&gt;Yes, this time we see the &lt;code&gt;postgres.exe&lt;/code&gt; usage, so it seems we have solved all our dependency problems.&lt;/p&gt;
&lt;h1 id="gonanoserver"&gt;Go NanoServer&lt;/h1&gt;
&lt;p&gt;Now we have a Windows Server Core image with PostgreSQL server. The image size is now 11.1GByte. Let's go one step further and make it a much smaller NanoServer image.&lt;/p&gt;
&lt;p&gt;In NanoServer we cannot run MSI packages or vcredist installers, and soon there is also no PowerShell. But with a so called &lt;strong&gt;multi-stage build&lt;/strong&gt; it's easy to &lt;code&gt;COPY&lt;/code&gt; deploy the PostgreSQL binaries and dependencies into a fresh NanoServer image.&lt;/p&gt;
&lt;p&gt;We append some more lines to our &lt;code&gt;Dockerfile&lt;/code&gt;. Most important line is the second &lt;code&gt;FROM&lt;/code&gt; line to start a new stage with the smaller NanoServer image.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM microsoft/nanoserver:10.0.14393.2007
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then we &lt;code&gt;COPY&lt;/code&gt; the &lt;code&gt;pgsql&lt;/code&gt; folder from the first stage into the NanoServer image, as well as the important runtime DLL's.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;COPY --from=download /pgsql /pgsql
COPY --from=download /windows/system32/msvcp120.dll /pgsql/bin/msvcp120.dll
COPY --from=download /windows/system32/msvcr120.dll /pgsql/bin/msvcr120.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Set the &lt;code&gt;PATH&lt;/code&gt; variable to have all tools accessible, expose the standard port and define a command.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;RUN setx /M PATH &amp;quot;C:\pgsql\bin;%PATH%&amp;quot;

EXPOSE 5432
CMD [&amp;quot;postgres&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now build the image again and try it out with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run postgres postgres.exe --help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/02/docker-run-postgres-nano.png" alt="docker run postgres in nano"&gt;&lt;/p&gt;
&lt;p&gt;We still see the usage, so the binaries also work fine in NanoServer. The final postgres images is down at 1.64GByte.&lt;br&gt;
If you do this with a NanoServer 1709 or Insider image the sizes is even smaller at 738MByte.&lt;/p&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;Process Monitor can help you find issues that prevent applications to run properly in Windows containers. Run it from a Server 2016 container host to observe your or a foreign application.&lt;/p&gt;
&lt;p&gt;I hope you find this blog post useful and I love to hear your feedback and experience about Windows containers. Just drop a comment below or ping me on Twitter &lt;a href="https://twitter.com/stefscherer"&gt;@stefscherer&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>Terraforming a Windows Insider Server in Azure</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;There may be different ways to run the Windows Insider Server Preview builds in Azure. Here's my approach to run a Windows Docker engine with the latest Insider build.&lt;/p&gt;
&lt;h2 id="buildtheazurevm"&gt;Build the Azure VM&lt;/h2&gt;
&lt;p&gt;On your local machine clone the &lt;a href="https://github.com/StefanScherer/packer-windows"&gt;packer-windows&lt;/a&gt; repo which has a Terraform template to build an Azure&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/terraforming-a-windows-insider-server-in-azure/</link><guid isPermaLink="false">5a64f348845d55000179abc4</guid><category>Azure</category><category>Docker</category><category>windows-containers</category><category>Insider</category><category>Windows</category><category>Terraform</category><category>Vagrant</category><category>Packer</category><dc:creator>Stefan Scherer</dc:creator><pubDate>Sun, 21 Jan 2018 21:32:41 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;There may be different ways to run the Windows Insider Server Preview builds in Azure. Here's my approach to run a Windows Docker engine with the latest Insider build.&lt;/p&gt;
&lt;h2 id="buildtheazurevm"&gt;Build the Azure VM&lt;/h2&gt;
&lt;p&gt;On your local machine clone the &lt;a href="https://github.com/StefanScherer/packer-windows"&gt;packer-windows&lt;/a&gt; repo which has a Terraform template to build an Azure VM. The template chooses a V3 machine which is able to run nested VM's.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/01/insider_in_azure_terraform_apply.png" alt="Create a VM in Azure with Terraform"&gt;&lt;/p&gt;
&lt;p&gt;You need &lt;a href="https://terraform.io"&gt;Terraform&lt;/a&gt; on your local machine which can be installed with a package manager.&lt;/p&gt;
&lt;p&gt;Mac:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brew install terraform
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Windows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;choco install terraform
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now clone the GitHub repo and go to the template.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/StefanScherer/packer-windows
cd packer-windows/nested/terraform
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Adjust the &lt;code&gt;variables.tf&lt;/code&gt; file with resource group name, account name and password, region and other things. You also need some information for Terraform to create resources in your Azure account. Please read the &lt;a href="https://www.terraform.io/docs/providers/azurerm/index.html"&gt;Azure Provider&lt;/a&gt; documentation for details how to obtain these values.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export ARM_SUBSCRIPTION_ID=&amp;quot;uuid&amp;quot;
export ARM_CLIENT_ID=&amp;quot;uuid&amp;quot;
export ARM_CLIENT_SECRET=&amp;quot;uuid&amp;quot;
export ARM_TENANT_ID=&amp;quot;uuid&amp;quot;

terraform apply
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command will take some minutes until the VM is up and running. It also runs a provision script to install further tools for you.&lt;/p&gt;
&lt;h2 id="rdpintothepackerbuildervm"&gt;RDP into the Packer builder VM&lt;/h2&gt;
&lt;p&gt;Now log into the Azure VM with a RDP client. This VM has Hyper-V installed as well as Packer and Vagrant, the tools we will use next.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/01/insider_in_azure_packer_build_vagrant_up.png" alt="Run Packer and Vagrant in Azure VM"&gt;&lt;/p&gt;
&lt;h2 id="buildtheinsidervm"&gt;Build the Insider VM&lt;/h2&gt;
&lt;p&gt;The next step is to build the Windows Insider Server VM. We will use &lt;a href="https://packer.io"&gt;Packer&lt;/a&gt; for the task. This produces a Vagrant box file that can be re-used locally on a Windows 10 machine.&lt;/p&gt;
&lt;p&gt;Clone the packer-windows repo and run the Packer build with the manually downloaded Insider ISO file.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/StefanScherer/packer-windows
cd packer-windows

packer build --only=hyperv-iso --var iso_url=~/Downloads/Windows_InsiderPreview_Server_2_17074.iso windows_server_insider_docker.json
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This command will take some minutes as it also downloads the Insider Docker images to have them cached when you start a new VM.&lt;/p&gt;
&lt;p&gt;Add the box file so it can be used by Vagrant.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vagrant box add windows_server_insider_docker windows_server_insider_docker_hyperv.box
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="boottheinsidervm"&gt;Boot the Insider VM&lt;/h2&gt;
&lt;p&gt;Now we're using &lt;a href="https://vagrantup.com"&gt;Vagrant&lt;/a&gt; to boot the Insider VM. I'll use my &lt;a href="https://github.com/StefanScherer/windows-docker-machine"&gt;windows-docker-machine&lt;/a&gt; Vagrant template which I also use locally on a Mac or Windows 10 laptop.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/StefanScherer/windows-docker-machine
cd windows-docker-machine
vagrant plugin install vagrant-reload

vagrant up --provider hyperv insider
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This will spin up a VM and creates TLS certificates for the Docker engine running in the Windows Insider Server VM.&lt;/p&gt;
&lt;p&gt;You could use it from the Azure VM, but we want to make the nested VM reachable from our laptop.&lt;/p&gt;
&lt;p&gt;Now retrieve the IP address of this nested VM to add some port mappings so we can access the nested VM from our local machine.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vagrant ssh-config
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Use the IP address shown for the next commands, eg. 192.168.0.10&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;netsh interface portproxy add v4tov4 listenport=2376 listenaddress=0.0.0.0 connectport=2376 connectaddress=192.168.0.10
netsh interface portproxy add v4tov4 listenport=9000 listenaddress=0.0.0.0 connectport=9000 connectaddress=192.168.0.10
netsh interface portproxy add v4tov4 listenport=3390 listenaddress=0.0.0.0 connectport=3389 connectaddress=192.168.0.10
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="createdockertlsforexternaluse"&gt;Create Docker TLS for external use&lt;/h2&gt;
&lt;p&gt;As we want to access this Docker engine from our local laptop we have to re-create the TLS certs with the FQDN of the Azure VM.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/01/insider_in_azure_rdp.png" alt="RDP to Azure and nested VM"&gt;&lt;/p&gt;
&lt;p&gt;Now RDP into the nested VM through port 3390 from your laptop.&lt;/p&gt;
&lt;p&gt;You will see a CMD terminal. Run &lt;code&gt;powershell&lt;/code&gt; to enter a PowerShell terminal.&lt;/p&gt;
&lt;p&gt;Run the &lt;code&gt;create-machine.ps1&lt;/code&gt; provision script again with the IP address and the FQDN of the Azure VM. Also specify the path of your local home directory (in my case &lt;code&gt;-machineHome /Users/stefan&lt;/code&gt;) to make the docker-machine configuration work.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;C:\Users\demo\insider-docker-machine\scripts\create-machine.ps1 -machineHome /Users/stefan -machineName az-insider -machineIp 1.2.3.4 -machineFqdn az-insider-01.westeurope.cloudapp.azure.com
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="rundockercontainers"&gt;Run Docker containers&lt;/h2&gt;
&lt;p&gt;You can copy the generated TLS certificates from the nested VM through the RDP session back to your home directory in &lt;code&gt;$HOME/.docker/machine/machines&lt;/code&gt; folder.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2018/01/insider_in_azure-1.png" alt="insider_in_azure-1"&gt;&lt;/p&gt;
&lt;p&gt;Then you can easily switch the Docker environment variables locally on your&lt;/p&gt;
&lt;p&gt;Mac:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;eval $(docker-machine env az-insider)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;or Windows:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker-machine env az-insider | iex
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you should be able to run Docker commands like&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker images
docker run -it microsoft/nanoserver-insider cmd
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id="conclusion"&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;We have used a lot of tools to create this setup. If you do this only once it seems to be more step than needed. But keep in mind the Insider builds are shipped regularly so you will do some steps again and again.&lt;/p&gt;
&lt;p&gt;To repeat some of these steps tools like Packer and Vagrant can help you go faster building VM's as Docker helps you go faster to ship your apps.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Packer helps you repeat building a VM from new ISO.&lt;/li&gt;
&lt;li&gt;Vagrant helps you repeat booting fresh VMs. Destroy early and often. Rebuild is cheap.&lt;/li&gt;
&lt;li&gt;Docker helps you repeat creating and running applications.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you have another approach to run Insider builds in Azure please let me know. I love to hear your story. Please use the comments below if you have questions or want to share your setup.&lt;/p&gt;
&lt;p&gt;If you liked this blog post please share it with your friends. You can follow me on Twitter &lt;a href="https://twitter.com/stefscherer"&gt;@stefscherer&lt;/a&gt; to stay updated with Windows containers.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>PoC: How to build images for 1709 without 1709</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;First of all: Happy Halloween! In this blog post you'll see some spooky things - or magic? Anyway I found a way to build Windows Docker images based on the new 1709 images without running on 1709. Sounds weird?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; The tools and described workflow to build such images on&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</description><link>http://localhost:2368/poc-build-images-for-1709-without-1709/</link><guid isPermaLink="false">59f90ee4f830c70001a9b8f1</guid><category>Docker</category><category>Windows Server 1709</category><category>windows-containers</category><category>AppVeyor</category><category>multi-arch</category><dc:creator>Stefan Scherer</dc:creator><pubDate>Tue, 31 Oct 2017 23:55:00 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;First of all: Happy Halloween! In this blog post you'll see some spooky things - or magic? Anyway I found a way to build Windows Docker images based on the new 1709 images without running on 1709. Sounds weird?&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Disclaimer:&lt;/strong&gt; The tools and described workflow to build such images on old Windows Server versions may break at any time. It works for me and some special cases, but it does not mean it works for any other use-case.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="the20161709gap"&gt;The 2016 &amp;lt;-&amp;gt; 1709 gap&lt;/h2&gt;
&lt;p&gt;As you might know from my &lt;a href="https://stefanscherer.github.io/docker-on-windows-server-1709/"&gt;previous blog post&lt;/a&gt; there is a gap between the old and new Windows images. You cannot pull the new 1709 Docker images on current Windows Server 2016. This means you also cannot build images without updating your build machines to Windows Server 1709.&lt;/p&gt;
&lt;h2 id="appveyor"&gt;AppVeyor&lt;/h2&gt;
&lt;p&gt;My favorite CI service for Windows is AppVeyor. They provide a Windows Server 2016 build agent with Docker and the latest base images installed. So it is very simple and convenient to build your Windows Docker images there. For example all my &lt;a href="https://github.com/StefanScherer/dockerfiles-windows"&gt;dockerfiles-windows&lt;/a&gt; Dockerfiles are built there and the images are pushed to Docker Hub.&lt;/p&gt;
&lt;p&gt;I guess it will take a while until we can choose another build agent to start building for 1709 there.&lt;/p&gt;
&lt;p&gt;But what should I do in the meantime?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Should I build all 1709 images manually on a local VM?&lt;/li&gt;
&lt;li&gt;Or spin up a VM in Azure? It is possible since today.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But then I don't have the nice GitHub integration. And I have to do all the maintenance of a CI server (cleaning up disk space and so on) myself. Oh I don't want to go that way.&lt;/p&gt;
&lt;h2 id="dockerimageshavelayers"&gt;Docker images have layers&lt;/h2&gt;
&lt;p&gt;Let's have a closer look at how a Docker image looks like. Each Docker image contains of one or more layers. Each layer is read-only. Any change will be done in a new layer on top of the underlying ones.&lt;/p&gt;
&lt;p&gt;For example the Windows Docker image of a Node.js application looks more or less like this:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/11/windows_image_layers-2.png" alt="windows_image_layers-2"&gt;&lt;/p&gt;
&lt;p&gt;At the bottom you find the Windows base image, then we add the Node.js runtime. Then we can add our application code on top of that. This is how a Dockerfile works. Every FROM, RUN, ... is an extra layer.&lt;/p&gt;
&lt;p&gt;Technically all layers are just tarballs with files and directories in it. So when the application and framework layer are independent from the OS system layer it should be possible to rearrange them with a new OS layer.&lt;/p&gt;
&lt;h2 id="rebasedockerimage"&gt;Rebase Docker image&lt;/h2&gt;
&lt;p&gt;That is what I have tried to find out. I studied the Docker Hub API and wrote a proof of concept to &amp;quot;rebase&amp;quot; a given Windows Docker image to swap the old Windows OS layers with another one.&lt;/p&gt;
&lt;p&gt;The tool works only with information from Docker Hub so it only retrieves metadata and pushes a new manifest back to the Docker Hub. This avoids downloading hundreds of megabytes for the old nanoserver images.&lt;/p&gt;
&lt;h3 id="usecases"&gt;Use cases&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Easily apply Windows Updates to an existing Windows app in seconds. Only the update layer will be swapped.&lt;/li&gt;
&lt;li&gt;Provide your app for all available Windows Update layers to avoid download.&lt;/li&gt;
&lt;li&gt;Sync multiple images based on different Windows Update layers to the current to avoid downloading several different udpate layers for a multi-container application.&lt;/li&gt;
&lt;li&gt;Create images for Server 1709 without having a machine for it.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="limits"&gt;Limits&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;You cannot move an app from a windowsservercore image to the nanoserver image.&lt;/li&gt;
&lt;li&gt;You also cannot move PowerShell scripts into the 1709 nanoserver image as there is no PowerShell installed.&lt;/li&gt;
&lt;li&gt;Your framework or application layer may has modified the Windows registry at build time. It then carries the old registry that may not fit to new base layer.&lt;/li&gt;
&lt;li&gt;Moving such old application layers on top of new base layers is some kind of time travel. Be warned that this tool may create corrupt images.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You can find the &lt;a href="https://github.com/StefanScherer/rebase-docker-image"&gt;rebase-docker-image&lt;/a&gt; tool on GitHub. It is a Node.js command line tool which is also available on NPM.&lt;/p&gt;
&lt;p&gt;The usage looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rebase-docker-image \
    stefanscherer/hello-freiburg:windows \
    -t stefanscherer/hello-freiburg:1709 \
    -b microsoft/nanoserver:1709
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You specify the existing image, eg. &amp;quot;stefanscherer/hello-freiburg:windows&amp;quot; which is based on nanoserver 10.0.14393.x.&lt;/p&gt;
&lt;p&gt;With the &lt;code&gt;-t&lt;/code&gt; option you specify the target image name that where the final manifest should be pushed.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;-b&lt;/code&gt; option specifies the base image you want to use, so most of the time the &amp;quot;microsoft/nanoserver:1709&amp;quot; image.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/11/rebase_docker_image.png" alt="rebase_docker_image"&gt;&lt;/p&gt;
&lt;p&gt;When we run the tool it does its job in only a few seconds:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Retrieving information about source image stefanscherer/hello-freiburg:windows
Retrieving information about source base image microsoft/nanoserver:10.0.14393.1715
Retrieving information about target base image microsoft/nanoserver:1709
Rebasing image
Pushing target image stefanscherer/hello-freiburg:1709
Done.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now on a Windows Server 1709 we can run the application.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/11/hello-freiburg-1709.png-shadow.png" alt="hello-freiburg-1709.png-shadow"&gt;&lt;/p&gt;
&lt;p&gt;I tried this tool with some other Windows Docker images and was able to rebase the golang:1.9-nanoserver image to have a Golang build environment for 1709 without rebuilding the Golang image by myself.&lt;/p&gt;
&lt;p&gt;But I also found situations where the rebase didn't work, so don't expect it to work everywhere.&lt;/p&gt;
&lt;h2 id="appveyorcipipeline"&gt;AppVeyor CI pipeline&lt;/h2&gt;
&lt;p&gt;I also want to show you a small CI pipeline using AppVeyor to build a Windows image with &lt;code&gt;curl.exe&lt;/code&gt; installed and provide two variants of that Docker image, one for the old nanoserver and one with the nanoserver:1709 image.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/blob/master/curl/Dockerfile"&gt;Dockerfile&lt;/a&gt; uses a multi-stage build. In the first stage we download and extract curl and its DLL's. The second stage starts again with the empty nanoserver (the fat one for Windows Server 2016) and then we just COPY deploy the binary into the fresh image. An ENTRYOINT finishes the final image.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM microsoft/nanoserver AS download
ENV CURL_VERSION 7.56.1
WORKDIR /curl
ADD https://skanthak.homepage.t-online.de/download/curl-$CURL_VERSION.cab curl.cab
RUN expand /R curl.cab /F:* .

FROM microsoft/nanoserver
COPY --from=download /curl/AMD64/ /
COPY --from=download /curl/CURL.LIC /
ENTRYPOINT [&amp;quot;curl.exe&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This image can be built on AppVeyor and pushed to the Docker Hub.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/blob/master/curl/push.ps1"&gt;push.ps1&lt;/a&gt; script pushes this image to Docker Hub.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker push stefanscherer/curl-windows:$version-2016
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Then the rebase tool will be installed and the 1709 variant will be pushed as well to Docker Hub.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;npm install -g rebase-docker-image
rebase-docker-image `
  stefanscherer/curl-windows:$version-2016 `
  -t stefanscherer/curl-windows:$version-1709 `
  -b microsoft/nanoserver:1709
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To provide my users the best experience I also draft a manifest list, just like we did for multi-arch images at the &lt;a href="https://stefanscherer.github.io/cross-build-nodejs-with-docker/"&gt;Captains Hack day&lt;/a&gt;. The final &amp;quot;tag&amp;quot; then contains both Windows OS variants.&lt;/p&gt;
&lt;p&gt;On Windows you can use Chocolatey to install the manifest-tool. In the future this feature will be integrated into the Docker CLI as &amp;quot;docker manifest&amp;quot; command.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;choco install -y manifest-tool
manifest-tool push from-spec manifest.yml
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/blob/master/curl/manifest.yml"&gt;manifest.yml&lt;/a&gt; lists both images and joins them together to the final &lt;code&gt;stefanscherer/curl-windows&lt;/code&gt; image.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;image: stefanscherer/curl-windows:7.56.1
tags: ['7.56', '7', 'latest']
manifests:
  -
    image: stefanscherer/curl-windows:7.56.1-2016
    platform:
      architecture: amd64
      os: windows
  -
    image: stefanscherer/curl-windows:7.56.1-1709
    platform:
      architecture: amd64
      os: windows
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So on both Windows Server 2016 and Windows Server 1709 the users can run the same image and it will work.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\Users\demo&amp;gt; docker run stefanscherer/curl-windows
curl: try 'curl --help' or 'curl --manual' for more information
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This requires the next Docker 17.10 EE version to work correctly, but it should be available soon. With older Docker engines it may pick the wrong version of the list of Docker images and fail running it.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;This way to &amp;quot;rebase&amp;quot; Docker images works astonishingly good, but keep in mind that this is not a general purpose solution. It is always better to use the correct version on the host to rebuild your Docker images the official way.&lt;/p&gt;
&lt;p&gt;Please use the comment below if you have further questions or share what you think about that idea.&lt;/p&gt;
&lt;p&gt;Stefan&lt;br&gt;
&lt;a href="https://twitter.com/stefscherer"&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>DockerCon: LCOW and Windows Server 1709</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Last week was a busy week as a Docker Captain. Many of us came to Copenhagen to DockerCon EU 2017. You may have heard of the surprising news about Kubernetes coming to Docker. But there were also some other new announcements about Windows Containers.&lt;/p&gt;
&lt;h2 id="dockeronwindowsworkshop"&gt;Docker on Windows Workshop&lt;/h2&gt;
&lt;p&gt;On Monday&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/dockercon-lcow-and-windows-server-1709/</link><guid isPermaLink="false">59f3b65cdd4c1b0001e301e7</guid><category>DockerCon</category><category>windows-containers</category><category>LCOW</category><category>Windows Server 1709</category><dc:creator>Stefan Scherer</dc:creator><pubDate>Sat, 28 Oct 2017 00:18:11 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Last week was a busy week as a Docker Captain. Many of us came to Copenhagen to DockerCon EU 2017. You may have heard of the surprising news about Kubernetes coming to Docker. But there were also some other new announcements about Windows Containers.&lt;/p&gt;
&lt;h2 id="dockeronwindowsworkshop"&gt;Docker on Windows Workshop&lt;/h2&gt;
&lt;p&gt;On Monday I helped &lt;a href="https://twitter.com/EltonStoneman"&gt;Elton Stoneman&lt;/a&gt; in his Docker on Windows Workshop. This time it was a full-day workshop and it was fully packed with 50 people.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/dowws.jpg" alt="Docker on Windows Workshop"&gt;&lt;/p&gt;
&lt;p&gt;Elton is always running the workshop at a rapic pace, but don't worry the workshop material is all public &lt;a href="https://github.com/sixeyed/docker-windows-workshop"&gt;available on GitHub&lt;/a&gt;. So we went through dockerizing &lt;a href="http://ASP.NET"&gt;ASP.NET&lt;/a&gt; apps, adding Prometheus, Grafana and an ELK stack for monitoring, building a Jenkins CI pipeline and finally running a Docker Swarm. There is lots of things to look up in the material. If you prefer a book, I can recommend his &lt;a href="https://www.amazon.de/Docker-Windows-Elt%E2%80%A6"&gt;Docker on Windows&lt;/a&gt; book which is also fully packed with many tips and tricks.&lt;/p&gt;
&lt;h2 id="lcowtheinsidestory"&gt;LCOW - The Inside Story&lt;/h2&gt;
&lt;p&gt;One of my favorite talks was by &lt;a href="https://twitter.com/gigastarks"&gt;John Starks&lt;/a&gt; from Microsoft about Linux Container on Windows - The Inside Story. He explained how LinuxKit is used to run a small HyperV VM for the Linux containers to provide the Linux kernel. On his Windows 10 1709 machine he also gave pretty good live demos. The &lt;a href="https://dockercon.docker.com/watch/U7Bxp66uKmemZssjCTyXkm"&gt;video is online&lt;/a&gt; and is worth watching.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/dcon-lcow.jpg" alt="Linux and Windows containers side-by-side"&gt;&lt;/p&gt;
&lt;p&gt;In the photo you can see an alpine and nanoserver container running side-by-side. So you will no longer need to switch between Linux and Windows containers, it just works. He also showed that volumes work between Linux and Windows containers. This demo was done with a special Docker engine as not all pull requests haven't been merged. But still challenging for me to try this on a own machine ...&lt;/p&gt;
&lt;h2 id="windowsserver1709"&gt;Windows Server 1709&lt;/h2&gt;
&lt;p&gt;During the DockerCon week Microsoft has announced the availability of Windows Server Version 1709 for download. I first looked at the Azure Portal, but found nothing yet. I also couldn't find the downloads.&lt;/p&gt;
&lt;p&gt;So after the LCOW talk I used a Windows 10 VM in Azure and installed the Fall Creators Update to have 1709 on that desktop machine. I found the missing pull request and compiled a Docker engine from source and then I had my LCOW moment:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/docker-run-lcow.gif" alt="docker-run-lcow"&gt;&lt;/p&gt;
&lt;p&gt;When you see this the first time working and know what technical details had to be solved make make it look so simple and easy - awesome!&lt;/p&gt;
&lt;p&gt;The next day I found the Windows Server 1709 ISO in my MSDN subscription. So I could start working on a Packer template in my &lt;a href="https://github.com/StefanScherer/packer-windows"&gt;packer-windows&lt;/a&gt; GitHub repo to automate the creation of such Windows VM's. But DockerCon is to meet people and learn new things: &lt;a href="https://twitter.com/NicholasDille"&gt;Nicholas Dille&lt;/a&gt; went another very interesting way to &lt;a href="http://dille.name/blog/2017/10/25/building-a-windowscontainer-docker-host-without-running-windows-setup/"&gt;build a VM with Docker without running Windows Setup&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="smallerwindowsimages"&gt;Smaller Windows images&lt;/h2&gt;
&lt;p&gt;In the last months we could follow the progress of the Windows Server in several Insider builds. I blogged about the &lt;a href="https://stefanscherer.github.io/exploring-new-nanoserver-insider-images/"&gt;smaller NanoServer Insider images&lt;/a&gt; in July going down to 80-90 MByte. Now with the new release of Windows Server 1709 and Windows 10 version 1709 we now can use official images.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;microsoft/windowsservercore:1709&lt;/li&gt;
&lt;li&gt;microsoft/nanoserver:1709&lt;/li&gt;
&lt;li&gt;microsoft/dotnet:2.0.0-*-nanoserver-1709&lt;/li&gt;
&lt;li&gt;microsoft/aspnet:4.7.1-windowsservercore-1709&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The biggest discussion is about having no PowerShell in the small nanoserver image. For me it's a nice fit to just &lt;code&gt;COPY&lt;/code&gt; deploy microservices into the Windows image.&lt;/p&gt;
&lt;p&gt;I haven't seen an official PowerShell base image based on nanoserver, but there is at least the beta version&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;microsoft/powershell:6.0.0-beta.9-nanoserver-1709&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I also have pushed some images to the Docker Hub to get started with other languages and tools.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/Bildschirmfoto-2017-10-19-um-11.14.43.png" alt="Bildschirmfoto-2017-10-19-um-11.14.43"&gt;&lt;/p&gt;
&lt;p&gt;If you don't have HyperV installed in Windows Server 1709 (maybe you are running a VM in the Cloud) then you cannot run older Windows Docker image on the new server. All images have to be built based on the new 1709 base images.&lt;/p&gt;
&lt;p&gt;Windows 10 users always use HyperV to run Linux or Windows containers, so you don't feel that hard constraint on your developer machine.&lt;/p&gt;
&lt;p&gt;It will be interesting to see how the multiple Windows versions evolve and when the next Insider program is giving us early access to the upcoming features.&lt;/p&gt;
&lt;h2 id="captainshackday"&gt;Captains Hack Day&lt;/h2&gt;
&lt;p&gt;On our Docker Captains Hack Day &lt;a href="https://twitter.com/mikesir87"&gt;Michael Irwin&lt;/a&gt; has started a better &lt;a href="https://github.com/mikesir87/swarm-viz"&gt;Swarm Visualizer 2.0&lt;/a&gt;. During the day we have added a first CI pipeline and - of course - Windows support. But not only Windows! With some magic multi-stage multi-arch builds we also managed to cross-build the visualizer on an Intel machine and create a Docker image for IBM z390 mainframes. &lt;a href="https://twitter.com/estesp"&gt;Phil Estes&lt;/a&gt; tested the image in the IBM cloud. I'll write a more detailed blog post about how to cross-build Node.js apps with Docker.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/captain-hack-day.jpg" alt="captain-hack-day"&gt;&lt;/p&gt;
&lt;p&gt;That was a fascinating week at DockerCon. Thanks to Jenny, Ashlinn, Victor, Mano ... for making this event so wonderful. I had a lot of hallway tracks to talk with many people about Windows Containers in devolpment and production. Share and learn!&lt;/p&gt;
&lt;p&gt;Stefan&lt;br&gt;
&lt;a href="https://twitter.com/stefscherer"&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>Use multi-stage builds for smaller Windows images</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;I'm still here in Austin, TX at DockerCon 2017 and I want to show you one of the announcements that is very useful to build small Windows Docker images.&lt;/p&gt;
&lt;p&gt;On Tuesday's first keynote at DockerCon Solomon Hykes introduced the most impressive feature for me that will make it in version&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/use-multi-stage-builds-for-smaller-windows-images/</link><guid isPermaLink="false">5986d4ec688a490001540974</guid><category>Docker</category><category>windows-containers</category><category>multi-stage</category><dc:creator>Stefan Scherer</dc:creator><pubDate>Wed, 19 Apr 2017 22:52:00 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;I'm still here in Austin, TX at DockerCon 2017 and I want to show you one of the announcements that is very useful to build small Windows Docker images.&lt;/p&gt;
&lt;p&gt;On Tuesday's first keynote at DockerCon Solomon Hykes introduced the most impressive feature for me that will make it in version 17.05.0 of Docker: &lt;strong&gt;The multi-stage builds&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/04/multi-stage-build.jpg" alt="announcement at DockerCon about multi-stage builds"&gt;&lt;/p&gt;
&lt;p&gt;The demo in the keynote only showed Linux images, but you can use this feature for Windows images as well.&lt;/p&gt;
&lt;h2 id="howdidwebuildsmallerimagesinthepast"&gt;How did we build smaller images in the past?&lt;/h2&gt;
&lt;p&gt;As we know each instruction in a &lt;code&gt;Dockerfile&lt;/code&gt; like &lt;code&gt;COPY&lt;/code&gt; or &lt;code&gt;RUN&lt;/code&gt; builds a new layer of the image. So everything you do in eg. a &lt;code&gt;RUN&lt;/code&gt; instruction is atomic and saved into one layer. It was a common practise to use multi-line &lt;code&gt;RUN&lt;/code&gt; instructions to clean up temporary files and cache folders before that instruction ends to minimize the size of that layer.&lt;/p&gt;
&lt;p&gt;For me it always looked like a workaround and a little too technical to know where all these temporary files have to be wiped out. So it is great to remove this noise out of your Dockerfiles.&lt;/p&gt;
&lt;p&gt;And another workaround that was used in addition was to create two Dockerfiles and a script to simulate such stages and copy files from the first Docker image back to the host and then into the second Docker image. This could lead to errors if you have old temp folders on your host where you copy the results from the first build in. So it will be good that we can remove this complexity and avoid such build scripts entirely.&lt;/p&gt;
&lt;h2 id="multistagebuildonwindows"&gt;Multi-stage build on Windows&lt;/h2&gt;
&lt;p&gt;The idea behind multi-stage builds is that you can define two or more build stages and only the layers of the last stage gets into the final Docker image.&lt;/p&gt;
&lt;h3 id="thefirststage"&gt;The first stage&lt;/h3&gt;
&lt;p&gt;As you can see in the nice slide you can start with a first stage and do what you like in there. Maybe you need a &lt;strong&gt;complete build environment&lt;/strong&gt; like MSBuild, or the Golang compiler or dev dependencies to run Node.js tests with your sources.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;FROM&lt;/code&gt; instruction now can be followed by a stage name, eg. &lt;code&gt;build&lt;/code&gt;. I recommend to introduce that to your &lt;code&gt;Dockefile&lt;/code&gt; as we will need this name later again. This is how your Dockerfile then could look like:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM microsoft/windowsservercore as build
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You do not need to use multi-line &lt;code&gt;RUN&lt;/code&gt; instructions any more if you haven't liked it. Just keep your Dockerfile &lt;strong&gt;simple, readable and maintainable&lt;/strong&gt; by your team colleages. The advantage that even you have is that you can use the Docker build cache much better.&lt;/p&gt;
&lt;p&gt;Think of a giant multi-line &lt;code&gt;RUN&lt;/code&gt; instruction with three big downloads, uncompress and cleanup steps and the third download crashes due to internet connectivity. Then you have to do all the other downloads again if you start the &lt;code&gt;docker build&lt;/code&gt; again.&lt;/p&gt;
&lt;p&gt;So relax and just download one file per &lt;code&gt;RUN&lt;/code&gt; instruction, even put the uncompress into another &lt;code&gt;RUN&lt;/code&gt; layer, it doesn't matter for the final image size.&lt;/p&gt;
&lt;h3 id="thelaststage"&gt;The last stage&lt;/h3&gt;
&lt;p&gt;The magic comes into the &lt;code&gt;Dockerfile&lt;/code&gt; as you can use more than one &lt;code&gt;FROM&lt;/code&gt; instructions. Each &lt;code&gt;FROM&lt;/code&gt; starts a new build stage and all lines beginning from the last &lt;code&gt;FROM&lt;/code&gt; will make it into the final Docker image. The last stage does not need to have a name like the previous ones.&lt;/p&gt;
&lt;p&gt;In this last stage you define the &lt;strong&gt;minimal runtime environment&lt;/strong&gt; for your containerised application.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;COPY&lt;/code&gt; instruction now has a new option &lt;code&gt;--from&lt;/code&gt; where you can specify from with stage you want to copy files or directories into the current stage.&lt;/p&gt;
&lt;p&gt;Enough theory. Let's have a look at some real use-cases I already tried out.&lt;/p&gt;
&lt;h2 id="buildagolangprogram"&gt;Build a Golang program&lt;/h2&gt;
&lt;p&gt;A simple multi-stage &lt;code&gt;Dockerfile&lt;/code&gt; to build a Golang binary from source could look like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM golang:nanoserver as gobuild
COPY . /code
WORKDIR /code
RUN go build webserver.go

FROM microsoft/nanoserver
COPY --from=gobuild /code/webserver.exe /webserver.exe
EXPOSE 8080
CMD [&amp;quot;\\webserver.exe&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first four lines describe the normal build. We copy the source codes into the Golang build environment and build the Windows binary with it.&lt;/p&gt;
&lt;p&gt;Then with the second &lt;code&gt;FROM&lt;/code&gt; instruction we choose an empty NanoServer image. With this we skip about 100 MByte of compressed Golang build environment images for the production image.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;COPY --from=gobuild&lt;/code&gt; instruction copies the final Windows binary from the gobuild stage into the final stage.&lt;/p&gt;
&lt;p&gt;The last two lines are just the normal things you do, expose the port on which your app is listening and describing the command that should be called when running a container with it.&lt;/p&gt;
&lt;p&gt;This &lt;code&gt;Dockerfile&lt;/code&gt; now can be easily be built as always with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t webserver .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The final Docker image only has a 2 MByte compressed layer in addition to the NanoServer base layers.&lt;/p&gt;
&lt;p&gt;You can find a full example for such a simple Golang webserver in my &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/tree/master/webserver"&gt;dockerfiles-windows&lt;/a&gt; repo, the final Docker Hub image is available at &lt;a href="https://hub.docker.com/r/stefanscherer/whoami/tags/"&gt;&lt;code&gt;stefanscherer/whoami:windows-amd64-1.2.0&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="installmongodbmsiinnanoserver"&gt;Install MongoDB MSI in NanoServer&lt;/h2&gt;
&lt;p&gt;Another example for this multi-stage build is that you can use it to &lt;strong&gt;install MSI packages&lt;/strong&gt; and put the installed programs and files &lt;strong&gt;into a NanoServer&lt;/strong&gt; image.&lt;/p&gt;
&lt;p&gt;Well, you cannot install MSI packages in NanoServer directly, but you can &lt;strong&gt;start with the Windows Server Core&lt;/strong&gt; image in the build stage and &lt;strong&gt;then switch to NanoServer&lt;/strong&gt; in the final stage.&lt;/p&gt;
&lt;p&gt;If you know where the software has been installed you can &lt;code&gt;COPY&lt;/code&gt; deploy them in the final stage into the image.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;Dockerfile&lt;/code&gt; how to build a MongoDB NanoServer image is also available &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/blob/142debf6ddeb9f5fb57d2d472ebf166a32dbcc87/mongo/3.4/Dockerfile"&gt;on GitHub&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/blob/142debf6ddeb9f5fb57d2d472ebf166a32dbcc87/mongo/3.4/Dockerfile#L1-L18"&gt;first stage&lt;/a&gt; more or less looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM microsoft/windowsservercore as msi
RUN &amp;quot;download MSI page&amp;quot;
RUN &amp;quot;check SHA sum of download&amp;quot;
RUN &amp;quot;run MSI installer&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/blob/142debf6ddeb9f5fb57d2d472ebf166a32dbcc87/mongo/3.4/Dockerfile#L20-L32"&gt;final stage&lt;/a&gt; looks like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM microsoft/nanoserver
COPY --from=msi C:\mongodb\ C:\mongodb\
...
RUN &amp;quot;put MongoDB binaries into PATH&amp;quot;
VOLUME C:\data\db
EXPOSE 27017
CMD [&amp;quot;mongod.exe&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Another pro tip: If you really want small Windows Docker images you should also avoid &lt;code&gt;RUN&lt;/code&gt; or &lt;code&gt;ENV&lt;/code&gt; instructions in the last stage.&lt;/p&gt;
&lt;p&gt;The final MongoDB NanoServer image is available at &lt;a href="https://hub.docker.com/r/stefanscherer/mongo-windows/tags/"&gt;&lt;code&gt;stefanscherer/mongo-windows:3.4.2-nano&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;With multi-stage builds coming into Docker 17.05 we will be able to&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;put all build stages into a single Dockerfile to use only one simple &lt;code&gt;docker build&lt;/code&gt; command&lt;/li&gt;
&lt;li&gt;use the build cache by using single line &lt;code&gt;RUN&lt;/code&gt; instructions&lt;/li&gt;
&lt;li&gt;start with ServerCore, then switch to NanoServer&lt;/li&gt;
&lt;li&gt;use latest NanoServer image with all security updates installed for the last stage even if upstream build layer may be out of date&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This gives you an idea what you will be able to do once you have Docker 17.05 or later installed.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Update 2017-05-07&lt;/strong&gt;: I build all my &lt;a href="https://github.com/StefanScherer/dockerfiles-windows"&gt;dockerfiles-windows&lt;/a&gt; Windows Docker images with &lt;a href="https://www.appveyor.com"&gt;AppVeyor&lt;/a&gt; and it is very easy to upgrade to Docker 17.05.0-ce during the build with the script &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/blob/d1c01effe957281f72a762914b7fae36bdf49c15/update-docker-ce.ps1"&gt;&lt;code&gt;update-docker-ce.ps1&lt;/code&gt;&lt;/a&gt;. For local Windows Server 2016 VM's you could use this script as well. Sure, at the moment we have to switch from EE to CE edition until 17.06.0-ee also will bring this feature. Your images will still run on 17.03.1-ee production servers.&lt;/p&gt;
&lt;p&gt;Please use the comments below if you have further ideas, questions or improvements to share. You can follow me on Twitter &lt;a href="https://twitter.com/stefscherer"&gt;@stefscherer&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>7 Reasons to attend DockerCon</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;I'm more than happy that I can make it to DockerCon in Austin, Texas. It is only a few weeks until the workshops and conference starts April, 17th. If you still need some good reasons why you should attend I can give you some ideas. And you will get 10%&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/7-reasons-to-attend-dockercon/</link><guid isPermaLink="false">5986d4ec688a490001540972</guid><category>DockerCon</category><category>Docker</category><category>ARM</category><category>windows-containers</category><dc:creator>Stefan Scherer</dc:creator><pubDate>Wed, 29 Mar 2017 22:43:00 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;I'm more than happy that I can make it to DockerCon in Austin, Texas. It is only a few weeks until the workshops and conference starts April, 17th. If you still need some good reasons why you should attend I can give you some ideas. And you will get 10% discount with the code &lt;strong&gt;CaptainStefan&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id="workshops"&gt;Workshops&lt;/h2&gt;
&lt;p&gt;On Monday I'll be at the workshop &lt;strong&gt;Modernizing monolithic &lt;a href="http://ASP.NET"&gt;ASP.NET&lt;/a&gt; applications with Docker&lt;/strong&gt; where you can get some hands-on experience with Windows containers. You cannot have a better place if you want to get started with Docker on Windows. Michael Friis and Elton Stoneman from Docker and myself can answer all your questions.&lt;/p&gt;
&lt;h2 id="seesomedockerswarmdemos"&gt;See some Docker Swarm demos&lt;/h2&gt;
&lt;p&gt;Come to the Community Theater on Tuesday, Apr 18th, 1:00 PM to see my live demo &lt;a href="https://dockercon.smarteventscloud.com/connect/sessionDetail.ww?SESSION_ID=109712"&gt;&lt;strong&gt;Swarm 2 Go&lt;/strong&gt;&lt;/a&gt; and how our team at SEAL Systems has built a portable multi-arch data center with Raspberry Pi and UP boards.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/03/picloud.jpg" alt="picloud"&gt;&lt;/p&gt;
&lt;p&gt;You will have the chance to play the chaos monkey and unplug cables to see Docker swarm mode in action. With the help of LED's we can visualise failures and how Docker swarm gets healthy again. All steps to build such a cluster is available in an &lt;a href="https://github.com/sealsystems/tiny-cloud"&gt;open source repo&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="learnaboutdockeronwindows"&gt;Learn about Docker on Windows&lt;/h2&gt;
&lt;p&gt;Docker is no longer a thing only on Linux. There are several talks about Docker on the Windows platform that I want to see.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dockercon.smarteventscloud.com/connect/sessionDetail.ww?SESSION_ID=107846"&gt;&lt;strong&gt;Docker for .NET developers&lt;/strong&gt;&lt;/a&gt; with Michele Leroux Bustamante, CIO, Solliance&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dockercon.smarteventscloud.com/connect/sessionDetail.ww?SESSION_ID=107848"&gt;&lt;strong&gt;Escape your VMs with Image2Docker&lt;/strong&gt;&lt;/a&gt; with Elton Stoneman from Docker and Docker Captain Jeff Nickoloff&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dockercon.smarteventscloud.com/connect/sessionDetail.ww?SESSION_ID=109233"&gt;&lt;strong&gt;Beyond \ - the path to Windows and Linux parity in Docker&lt;/strong&gt;&lt;/a&gt; with Taylor Brown, Principal Lead Program Manager, Microsoft&lt;/li&gt;
&lt;li&gt;&lt;a href="https://dockercon.smarteventscloud.com/connect/sessionDetail.ww?SESSION_ID=106041"&gt;&lt;strong&gt;Creating Effective Images&lt;/strong&gt;&lt;/a&gt; with Abby Fuller, Technical Evangelist, AWS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And I also recommend to visit the Microsoft booth to hopefully see some Docker swarm mode on Windows Servers. I really look forward to see the latest news and talking with some of the Microsoft Container and Networking team.&lt;/p&gt;
&lt;h2 id="multipleplatforms"&gt;Multiple platforms&lt;/h2&gt;
&lt;p&gt;If you think Docker is only Linux on Intel machines, then comparing it to an instrument it may look like this.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/03/keyboard-535254_1920.jpg" alt="keyboard"&gt;&lt;/p&gt;
&lt;p&gt;But as you can see the talks above, Docker is available on multiple platforms: Linux, Windows, from small ARM devices like the Raspberry Pi to big IBM machines.&lt;/p&gt;
&lt;p&gt;So the whole spectrum of Docker more looks like this, and once you learned the Docker commands you are able to play this:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/03/pipe-organ-669589_1920.jpg" alt="organ"&gt;&lt;/p&gt;
&lt;p&gt;So it is time to learn how easy it is to deploy your applications for more than one platform.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dockercon.smarteventscloud.com/connect/sessionDetail.ww?SESSION_ID=106642"&gt;&lt;strong&gt;From Arm to Z: Building, Shipping, and Running a Multi-platform Docker Swarm&lt;/strong&gt;&lt;/a&gt; with Christopher Jones and Christy Perez from IBM&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;See you at DockerCon! Ping me on Twitter &lt;a href="https://twitter.com/stefscherer"&gt;@stefscherer&lt;/a&gt; or with the DockerCon app to get in touch with me during that conference week.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item></channel></rss></html>