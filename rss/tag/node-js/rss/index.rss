<!DOCTYPE html>
<html><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:media="http://search.yahoo.com/mrss/" version="2.0"><channel><title>Node.js - Stefan Scherer's Blog</title><description>Just my techie notes.</description><link>http://localhost:2368/</link><image><url>http://localhost:2368/favicon.png</url><title>Node.js - Stefan Scherer's Blog</title><link>http://localhost:2368/</link></image><generator>Ghost 1.8</generator><lastBuildDate>Wed, 14 Feb 2018 23:24:26 GMT</lastBuildDate><atom:link href="http://localhost:2368/tag/node-js/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title>Cross-build a Node.js app with Docker and deploy to IBM Cloud</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;After the DockerCon EU and the Moby Summit in Copenhagen last week we also had an additional Docker Captain's Hack Day. After introducing our current projects to the other Captains we also had time to work together on some ideas.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&amp;quot;Put all Captains available into a room, feed them&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;/div&gt;</description><link>http://localhost:2368/cross-build-nodejs-with-docker/</link><guid isPermaLink="false">59f7701f71f6240001940592</guid><category>Docker</category><category>Node.js</category><category>multi-arch</category><dc:creator>Stefan Scherer</dc:creator><pubDate>Mon, 30 Oct 2017 22:37:03 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;After the DockerCon EU and the Moby Summit in Copenhagen last week we also had an additional Docker Captain's Hack Day. After introducing our current projects to the other Captains we also had time to work together on some ideas.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;&amp;quot;Put all Captains available into a room, feed them well and see what's happening.&amp;quot;&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/captains-hack-day.jpg" alt="captains-hack-day"&gt;&lt;/p&gt;
&lt;h2 id="modernizingswarmvisualizer"&gt;Modernizing Swarm Visualizer&lt;/h2&gt;
&lt;p&gt;One of the ideas was Swarm Visualizer 2.0. Michael Irwin came up with the idea to rewrite the current Visualizer to be event driven, use a modern React framework and cleanup the code base.&lt;/p&gt;
&lt;p&gt;The old one uses a dark theme and shows lots of details for the services with small fonts.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/Bildschirmfoto-2017-10-30-um-19.47.10.png" alt="old swarm visualizer"&gt;&lt;/p&gt;
&lt;p&gt;Here's a screenshot of an early version of the new UI. With a click on one of the tasks you get more details about that task and its service. All information is updated immediately when you update the service (eg. add or remove labels).&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/Bildschirmfoto-2017-10-30-um-19.50.18.png" alt="new swarm visualizer"&gt;&lt;/p&gt;
&lt;p&gt;You can try this new Swarm visualizer yourself with the following command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker container run \
  --name swarm-viz \
  -p 3000:3000 \
  -v /var/run/docker.sock:/var/run/docker.sock \
  mikesir87/swarm-viz
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I joined Michael's table as I was curious if we can have this visualizer for Windows, too. Especially the new Windows Server 1709 that makes mapping the Docker API into a Windows container as easy as on Linux.&lt;/p&gt;
&lt;p&gt;In this blog post I focus on how to build a Node.js app with Docker and don't look into the details of the app itself. I'll show how to improve the Dockerfile to build for multiple platforms and finally how to build a CI pipeline for that. You can find the project on &lt;a href="https://github.com/mikesir87/swarm-viz"&gt;github.com/mikesir87/swarm-viz&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="initialdockerfile"&gt;Initial Dockerfile&lt;/h2&gt;
&lt;p&gt;The application is built inside a Docker container. So you even can build it without any developer tools installed, you only need Docker.&lt;/p&gt;
&lt;p&gt;Let's have a look at the first version of the Dockerfile for the Linux image. It is a multi-stage build with three stages:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;# Build frontend
FROM node:8.7-alpine as frontend
WORKDIR /app
COPY client/package.json .
RUN npm install
COPY client/ .
RUN npm run build

# Build backend
FROM node:8.7-alpine as backend
WORKDIR /app
COPY api/package.json .
RUN npm install
COPY api/ .
RUN npm run build

# Put them together
FROM node:8.7-alpine
EXPOSE 3000
WORKDIR /app
COPY api/package.json .
RUN npm install --production
COPY --from=backend /app/dist /app/dist
COPY --from=frontend /app/build /app/build
CMD node /app/dist/index.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first stage uses &lt;code&gt;FROM node:8.7-alpine&lt;/code&gt; to build the frontend in a container.&lt;/p&gt;
&lt;p&gt;The second stage builds the backend in another Alpine container. During that build you also need some development dependencies that aren't needed for the final image.&lt;/p&gt;
&lt;p&gt;In the third stage only the dependencies that are relevant at runtime are installed with &lt;code&gt;npm install --production&lt;/code&gt;. All artifacts needed from the other stages are also copied into the final image.&lt;/p&gt;
&lt;h2 id="makefrommoreflexibleforwindows"&gt;Make FROM more flexible for Windows&lt;/h2&gt;
&lt;p&gt;I tried to build the app for Windows Server 1709 and had to create a second Dockerfile as I have to use another &lt;code&gt;FROM&lt;/code&gt; as node does not have a Windows variant in the official images. And Windows Server 1709 just came out so I had to create a Node.js base image for Windows myself.&lt;/p&gt;
&lt;p&gt;So what I did was copying the Dockerfile to Dockerfile.1709 and changed all the&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM node:8.7-alpine
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;lines into&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM stefanscherer/node-windows:1709
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;But now we have duplicated the Dockerfile &amp;quot;code&amp;quot; for only this little difference.&lt;/p&gt;
&lt;p&gt;Fortunately you now can use build arguments for the &lt;code&gt;FROM&lt;/code&gt; instruction. So with only a little change we can have &lt;strong&gt;ONE&lt;/strong&gt; Dockerfile for Linux and Windows.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;ARG node=node:8.7-alpine
FROM $node as frontend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/add-arg.png" alt="add-arg"&gt;&lt;/p&gt;
&lt;p&gt;On Linux you still can build the image as before without any change.&lt;/p&gt;
&lt;p&gt;On Windows I now was able to use this Dockerfile with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker image build -t viz `
  --build-args node=stefanscherer/node-windows:1709 .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and use a Windows Node.js base image for all stages. &lt;a href="https://github.com/mikesir87/swarm-viz/pull/2"&gt;First pull request&lt;/a&gt; done. Check! ðŸ˜Š&lt;/p&gt;
&lt;p&gt;And running the manually built image in Windows Server 1709 looks very similar to Linux:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker container run `
  -p 3000:3000 `
  -u ContainerAdministrator `
  -v //./pipe/docker_engine://./pipe/docker_engine `
  viz
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="goingmultiarch"&gt;Going multi-arch&lt;/h2&gt;
&lt;p&gt;We showed the Windows Swarm visualizer to other Captains and we discussed how to go to more platforms. Phil Estes, a very active member of the Docker community who's helping push the multi-architecture support in Docker forward and the maintainer of the &lt;a href="https://github.com/estesp/manifest-tool"&gt;manifest-tool&lt;/a&gt;, commented:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;With Golang it is easy to build multi-arch images, just cross-build a static binary with &lt;code&gt;GOARCH=bar go build app.go&lt;/code&gt; and copy the binary in an empty &lt;code&gt;FROM scratch&lt;/code&gt; image.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Hm, we use Node.js here, so what has to be done instead?&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/captain-hack-day-1.jpg" alt="captain-hack-day-1"&gt;&lt;/p&gt;
&lt;p&gt;Well, instead of the &lt;code&gt;scratch&lt;/code&gt; image we need the &lt;code&gt;node&lt;/code&gt; image for the Node.js runtime. So we had to &lt;strong&gt;choose the desired architecture&lt;/strong&gt; and then copy all sources and dependencies into that image.&lt;/p&gt;
&lt;p&gt;Our Node.js application uses Express, Dockerode and some other dependencies, that are platform independent. So this simple copy approach should do it, we thought.&lt;/p&gt;
&lt;p&gt;We added another build stage in the Dockerfile where we switch to the desired platform. You may know, the &lt;code&gt;node&lt;/code&gt; image on Docker Hub is already a multi-arch image. But in this case we want to build - let's say on Linux/amd64 - for another platform like the IBM s390 mainframe.&lt;/p&gt;
&lt;p&gt;With another build argument to specify the target platform for the final stage we came up with this:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;ARG node=node:8.7-alpine
ARG target=node:8.7-alpine

FROM $node as frontend
...

FROM $target
EXPOSE 3000
COPY --from=proddeps /app /app
CMD node /app/dist/index.js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/add-target.png" alt="add-target"&gt;&lt;/p&gt;
&lt;p&gt;As Phil works for IBM he could easily verify our approach. We built an IBM version of the Swarm visualizer with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker image build -t mikesir87/swarm-viz \
  --build-arg target=s390x/node:8.7 .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and pushed it to the Docker Hub. Phil then pulled and started the container in IBM Cloud and showed us the visualizer UI. Hurray!&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/deploy-to-ibm.jpg" alt="deploy-to-ibm"&gt;&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/mikesir87/swarm-viz/pull/2"&gt;second pull request&lt;/a&gt; was accepted. Check! ðŸŽ‰&lt;/p&gt;
&lt;p&gt;Now we needed some more automation to build and push the Docker images.&lt;/p&gt;
&lt;h2 id="addingamultiarchcipipeline"&gt;Adding a multi-arch CI pipeline&lt;/h2&gt;
&lt;p&gt;I've done that several times for my Raspberry Pi projects, so cherry-picked the relevant parts from other repos. For the CI pipeline we choose Travis CI, but any other CI cloud service could be used that allows multi-stage builds.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/mikesir87/swarm-viz/blob/master/.travis.yml"&gt;.travis.yml&lt;/a&gt; uses a matrix build for all architectures. Currently we're building it for only two platforms:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-yaml"&gt;sudo: required

services:
 - docker

env:
  matrix:
    - ARCH=amd64
    - ARCH=s390x

script:
  - ./travis-build.sh
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="build"&gt;build&lt;/h3&gt;
&lt;p&gt;The &lt;a href="https://github.com/mikesir87/swarm-viz/blob/master/travis-build.sh"&gt;travis-build.sh&lt;/a&gt; then is called for each architecture of that matrix and we run the corresponding build.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker image build -t mikesir87/swarm-viz \
    --build-arg target=$ARCH/node:8.7 .
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="deploy"&gt;deploy&lt;/h3&gt;
&lt;p&gt;As a final step in the .travis.yml we push every image to Docker Hub and tag it with the Git commit id. At this early stage of the project this is good enough. Later on you can think of tagged release builds etc.&lt;/p&gt;
&lt;p&gt;The &lt;a href="https://github.com/mikesir87/swarm-viz/blob/master/travis-deploy.sh"&gt;travis-deploy.sh&lt;/a&gt; pushes the Docker image for each architecture to the Docker Hub with a different tag using the &lt;code&gt;$ARCH&lt;/code&gt; variable we get from the matrix build.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker image push &amp;quot;$image:linux-$ARCH-$TRAVIS_COMMIT&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In the amd64 build we additionally download and use the manifest-tool to push a manifest list with the final tag.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;manifest-tool push from-args \
    --platforms linux/amd64,linux/s390x \
    --template &amp;quot;$image:OS-ARCH-$TRAVIS_COMMIT&amp;quot; \
    --target &amp;quot;$image:latest&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can verify that the &lt;code&gt;latest&lt;/code&gt; tag is already a manifest list with another Docker image provided by Phil&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker container run --rm mplatform/mquery mikesir87/swarm-viz
Image: mikesir87/swarm-viz:latest
 * Manifest List: Yes
 * Supported platforms:
   - amd64/linux
   - s390x/linux
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="futureimprovements"&gt;Future improvements&lt;/h2&gt;
&lt;p&gt;In the near future we will also add a Windows build using AppVeyor CI to provide Windows images and also put them into the manifest list. This step would also be needed for Golang projects as you cannot use the empty &lt;code&gt;scratch&lt;/code&gt; image on Windows.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/10/ci-pipeline-1.png" alt="ci-pipeline-1"&gt;&lt;/p&gt;
&lt;p&gt;If you watch closely we have used &lt;code&gt;node:8.7&lt;/code&gt; for the final stage. There is no multi-arch &lt;code&gt;alpine&lt;/code&gt; image, so there also is no &lt;code&gt;node:8.7-alpine&lt;/code&gt; as multi-arch image. But the maintainers of the official Docker images are working hard to add this missing piece to have small images for all architectures.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ docker container run --rm mplatform/mquery node:8.7-alpine
Image: node:8.7-alpine
 * Manifest List: Yes
 * Supported platforms:
   - amd64/linux
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;At the end of the Hack day we were really excited how far we came in only a few hours and learned that cross-building Node.js apps with Docker and deploying them as multi-arch Docker images isn't that hard.&lt;/p&gt;
&lt;p&gt;Best of all, the users of your Docker images don't have to think about these details. They just can run your image on any platform. Just use the command I showed at the beginning as this already uses the multi-arch variant of the next Swarm visualizer app.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;So give multi-arch a try in your next Node.js project to run your app on any platform!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;If you want to learn more about multi-arch (and you want to see Phil with a bow tie) then I can recommend the &lt;a href="https://dockercon.docker.com/watch/Q2LpoYRL3drmxzWc8yDmn9"&gt;Docker Multi-arch All the Things&lt;/a&gt; talk from DockerCon EU with Phil Estes and Michael Friis.&lt;/p&gt;
&lt;p&gt;In my lastest &lt;a href="https://www.slideshare.net/stefscherer/bauen-und-verteilen-von-multiarch-docker-images-fr-linux-und-windows"&gt;multi-arch slidedeck&lt;/a&gt; there are also more details about the upcoming &lt;code&gt;docker manifest&lt;/code&gt; command that will replace the manifest-tool in the future.&lt;/p&gt;
&lt;p&gt;Thanks &lt;a href="https://twitter.com/mikesir87"&gt;Michael&lt;/a&gt; for coming up with that idea, thanks &lt;a href="https://twitter.com/estesp"&gt;Phil&lt;/a&gt; for the manifest-tool and testing the visualizer. Thanks &lt;a href="https://twitter.com/quintus23m"&gt;Dieter&lt;/a&gt; and &lt;a href="https://twitter.com/bretfisher"&gt;Bret&lt;/a&gt; for the photos. You can follow us on Twitter to see what these Captains are doing next.&lt;/p&gt;
&lt;p&gt;Stefan&lt;br&gt;
&lt;a href="https://twitter.com/stefscherer"&gt;@stefscherer&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>Exploring new NanoServer Insider images</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Last week the first Insider preview container images appeared on the Docker Hub. They promise us much smaller sizes to have more lightweight Windows images for our applications.&lt;/p&gt;
&lt;p&gt;To use these Insider container images you also need an Insider preview of Windows Server 2016 or Windows 10. Yes, this is&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/exploring-new-nanoserver-insider-images/</link><guid isPermaLink="false">5986d4ec688a490001540975</guid><category>Docker</category><category>Windows</category><category>Nano Server</category><category>Node.js</category><category>Vagrant</category><category>Packer</category><category>Docker Hub</category><category>Insider</category><dc:creator>Stefan Scherer</dc:creator><pubDate>Tue, 18 Jul 2017 09:42:41 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Last week the first Insider preview container images appeared on the Docker Hub. They promise us much smaller sizes to have more lightweight Windows images for our applications.&lt;/p&gt;
&lt;p&gt;To use these Insider container images you also need an Insider preview of Windows Server 2016 or Windows 10. Yes, this is another great announcement that you can get early access and give feedback to the upcoming version of Windows Server. So let's grab it.&lt;/p&gt;
&lt;h2 id="windowsserverinsider"&gt;Windows Server Insider&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Register at Windows Insider program &lt;a href="https://insider.windows.com"&gt;https://insider.windows.com&lt;/a&gt; and join the Windows Server Insider program.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Download the Windows Server Insider preview ISO from &lt;a href="https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewserver"&gt;https://www.microsoft.com/en-us/software-download/windowsinsiderpreviewserver&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Now you can create a VM and install Docker. You can either build the VM manually and follow the docs &lt;a href="https://docs.microsoft.com/en-us/virtualization/windowscontainers/quick-start/using-insider-container-images"&gt;&amp;quot;Using Insider Container Images&amp;quot;&lt;/a&gt; how to install Docker and pull the Insider container images. Or you can use my Packer template and Vagrant environment to automate these steps. The walkthrough is described at&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/StefanScherer/insider-docker-machine"&gt;https://github.com/StefanScherer/insider-docker-machine&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="windowsinsiderimages"&gt;Windows Insider images&lt;/h2&gt;
&lt;p&gt;There are four new Docker images available with a much smaller footprint.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/07/windows_insider_images.png" alt="Windows Insider images"&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;microsoft/windowsservercore-insider&lt;/li&gt;
&lt;li&gt;microsoft/nanoserver-insider&lt;/li&gt;
&lt;li&gt;microsoft/nanoserver-insider-dotnet&lt;/li&gt;
&lt;li&gt;microsoft/nanoserver-insider-powershell&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The Windows Server Core Insider image got down from 5 GB to only 2 GB which saves a lot of bandwidth and download time.&lt;/p&gt;
&lt;p&gt;You may wonder why there are three Nano Server Insider images and why there is one without PowerShell.&lt;/p&gt;
&lt;h2 id="aimingthesmallestwindowsbaseimage"&gt;Aiming the smallest Windows base image&lt;/h2&gt;
&lt;p&gt;If we compare the image sizes of the current &lt;code&gt;microsoft/nanoserver&lt;/code&gt; image with its base layer and update layer with the new Insider images you can see the reason.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/07/nanoserver_sizes.png" alt="NanoServer sizes"&gt;&lt;/p&gt;
&lt;p&gt;If you want to ship your application in a container image you don't want to ship a whole operating system, but only the parts needed to run the application.&lt;/p&gt;
&lt;p&gt;And to ship faster is to ship smaller images. For many applications you do not need eg. PowerShell inside your base image at runtime which would take another 54 MByte to download from the Docker registry.&lt;/p&gt;
&lt;p&gt;Let's have a look at current Windows Docker images available on the Docker Hub. To run a Golang webserver for example on an empty Windows Docker host you have to pull the 2MB binary and the two NanoServer base layers with hundreds of MB to run it in a container.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/07/docker-pull-whoami.png" alt="docker pull whoami"&gt;&lt;/p&gt;
&lt;p&gt;Of course these base images have to be downloaded only once as other NanoServer container images will use the same base image. But if you work with Windows containers for a longer time you may have noticed that you still have to download different update layers from time to time that pull another 122 MB.&lt;/p&gt;
&lt;p&gt;And if the NanoServer base image is much smaller then the updates also will be smaller and faster to download.&lt;/p&gt;
&lt;p&gt;With the new Insider container images you can build and run containerized .NET core applications that are still smaller than the NanoServer + PowerShell base image.&lt;/p&gt;
&lt;h2 id="nodejs"&gt;Node.js&lt;/h2&gt;
&lt;p&gt;Another example is providing a Node.js container image based on the new NanoServer Insider image with only 92 MByte. We have just cut off &amp;quot;3&amp;quot; hundred MB.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/07/nodejs_nanoserver_sizes-3.png" alt="Node.js NanoServer sizes"&gt;&lt;/p&gt;
&lt;p&gt;If we compare that with some of the Linux Node.js container images we are at about the size of the the slim images.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/07/Bildschirmfoto-2017-07-14-um-08.53.24.png" alt="Node.js slim image sizes"&gt;&lt;/p&gt;
&lt;h2 id="multistagebuild"&gt;Multi-stage build&lt;/h2&gt;
&lt;p&gt;To build such small Windows images comes with a cost. You have to live without PowerShell. But the new multi-stage build introduced with Docker 17.05 really helps you and you can use PowerShell before the final image layers are built.&lt;/p&gt;
&lt;p&gt;If you haven't heard about multi-stage builds its concept is to have multiple &lt;code&gt;FROM&lt;/code&gt; instructions in a &lt;code&gt;Dockerfile&lt;/code&gt;. Only the last &lt;code&gt;FROM&lt;/code&gt; until the end of the file will build the final container image. This is also called the last stage. In all the other stages you don't have to optimze too much and can use the build cache much better. You can read more about &lt;a href="https://blog.docker.com/2017/07/multi-stage-builds/"&gt;multi-stage builds&lt;/a&gt; at the Docker Blog.&lt;/p&gt;
&lt;p&gt;Let's have a closer look how to build a small Node.js base image. You can find the complete &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/blob/07cedcf2cc93e669bba9c961121feda6f43dab59/node/8.1/nano/Dockerfile"&gt;Dockerfile&lt;/a&gt; on GitHub.&lt;/p&gt;
&lt;p&gt;In the first stage I'm lazy and even use the &lt;code&gt;microsoft/windowsservercore-insider&lt;/code&gt; image. The reason is that I'm using the GPG tools to verify the downloads and these tools don't run quiet well in NanoServer at the moment.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;# escape=`
FROM microsoft/windowsservercore-insider as download
SHELL [&amp;quot;powershell&amp;quot;, &amp;quot;-Command&amp;quot;, &amp;quot;$ErrorActionPreference = 'Stop'; $ProgressPreference = 'SilentlyContinue';&amp;quot;]
RUN Invoke-WebRequest ... 
RUN Expand-Archive ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;Dockerfile&lt;/code&gt; has a second &lt;code&gt;FROM&lt;/code&gt; instruction which then uses the smallest Windows base image. In that stage you normally &lt;code&gt;COPY&lt;/code&gt; deploy files and folders from previous stages. In our case we copy the Node.js installation folder into the final image.&lt;/p&gt;
&lt;p&gt;The one &lt;code&gt;RUN&lt;/code&gt; instruction sets the &lt;code&gt;PATH&lt;/code&gt; environment variable with the &lt;code&gt;setx&lt;/code&gt; command instead of PowerShell commands.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM microsoft/nanoserver-insider
ENV NPM_CONFIG_LOGLEVEL info
COPY --from=download /nodejs /nodejs
RUN setx PATH &amp;quot;%PATH%;C:\nodejs;%APPDATA%\npm&amp;quot;
CMD [ &amp;quot;node.exe&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Users of such a Node.js base image can work as usual by &lt;code&gt;COPY&lt;/code&gt; deploy their source tree and node_modules folder into that image and run the application as a small container.&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM stefanscherer/node-windows:8.1.4-insider
WORKDIR /code
COPY . /code
CMD [&amp;quot;node.exe&amp;quot;, &amp;quot;app.js&amp;quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;So all you have to do is change the &lt;code&gt;FROM&lt;/code&gt; instruction to the smaller insider Node.js image.&lt;/p&gt;
&lt;h2 id="furtherinsiderimages"&gt;Further Insider images&lt;/h2&gt;
&lt;p&gt;I have pushed some of my first Insider images to the Docker Hub so it may be easier for you to try out different languages.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stefanscherer/node-windows:6.11.1-insider&lt;/li&gt;
&lt;li&gt;stefanscherer/node-windows:8.1.4-insider&lt;/li&gt;
&lt;li&gt;stefanscherer/golang-windows:1.8.3-insider&lt;/li&gt;
&lt;li&gt;stefanscherer/dockertls-windows:insider&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you want to see how these images are built, then you can find the &lt;code&gt;Dockerfiles&lt;/code&gt; in the latest pull requests of my &lt;a href="https://github.com/StefanScherer/dockerfiles-windows"&gt;https://github.com/StefanScherer/dockerfiles-windows&lt;/a&gt; repo.&lt;/p&gt;
&lt;h2 id="dockervolumes"&gt;Docker Volumes&lt;/h2&gt;
&lt;p&gt;If you have worked with Docker Volumes on Windows you may know this already. Node.js and other tools and languages have problems when they want to get the real name of a file or folder that is mapping from the Docker host into the container.&lt;/p&gt;
&lt;p&gt;Node.js for example thinks the file is in the folder &lt;code&gt;C:\ContainerMappedDirectories&lt;/code&gt;, but cannot find the file there. There is a workaround described in Elton Stoneman's blog post &lt;a href="https://blog.sixeyed.com/docker-volumes-on-windows-the-case-of-the-g-drive/"&gt;&amp;quot;Introducing the 'G' Drive&amp;quot;&lt;/a&gt; to map it to another drive letter.&lt;/p&gt;
&lt;p&gt;With the new Insider preview I see a great improvement on that topic. Running normal Windows containers without the HyperV isolation there is no longer a symbolic link.&lt;/p&gt;
&lt;p&gt;If we run the Node.js container interactively and map the folder &lt;code&gt;C:\code&lt;/code&gt; into the container we can list the &lt;code&gt;C:&lt;/code&gt;drive and see that the &lt;code&gt;code&lt;/code&gt; folder is a normal directory.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -v C:\code:C:\code stefanscherer/node-windows:8.1.4-insider cmd /c dir
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/07/docker-run-nodejs.png-shadow.png" alt="docker run volume"&gt;&lt;/p&gt;
&lt;p&gt;With this setup you are able to mount your source code into the Node.js container and run it eg. with &lt;code&gt;nodemon&lt;/code&gt; to live reload it after changing it on the host.&lt;/p&gt;
&lt;p&gt;Unfortunately this is not available with the Hyper-V isolation that is the default on Windows 10 Insider machines.&lt;/p&gt;
&lt;p&gt;Running the same command with &lt;code&gt;--isolation=hyperv&lt;/code&gt; shows the symlinked directory which Node.js cannot handle at the moment.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -v C:\code:C:\code --isolation=hyperv stefanscherer/node-windows:8.1.4-insider cmd /c dir
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2017/07/docker-run-nodejs-hyperv.png-shadow.png" alt="docker run volume hyperv"&gt;&lt;/p&gt;
&lt;p&gt;But this improvement in native Windows containers looks very promising to solve a lot of headache for all the maintainers of Git for Windows, Golang, Node.js and so on.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Having smaller Windows container images is a huge step forward. I encourage you to try out the much smaller images. You'll learn how it feels to work with them and you can give valuable feedback to the Microsoft Containers team shaping the next version of Windows Server.&lt;/p&gt;
&lt;p&gt;Can we make even smaller images? I don't know, but let's find it out. How about naming the new images? Please make suggestions at the Microsoft Tech Community &lt;a href="https://techcommunity.microsoft.com"&gt;https://techcommunity.microsoft.com&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Please use the comments below if you have further ideas, questions or improvements to share. You can follow me on Twitter &lt;a href="https://twitter.com/stefscherer"&gt;@stefscherer&lt;/a&gt; to stay up to date with Windows containers.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>Is there a Windows Docker image for ...?</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Do you want to try out Windows containers, but don't want to start too low level? If you are using one of the following programming languages you can benefit of already available official Docker images for Windows.&lt;/p&gt;
&lt;p&gt;These Docker images are well maintained and you can just start and put&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/is-there-a-windows-docker-image-for/</link><guid isPermaLink="false">5986d4ec688a490001540970</guid><category>Docker</category><category>Windows</category><category>Golang</category><category>Python</category><category>Node.js</category><category>Java</category><dc:creator>Stefan Scherer</dc:creator><pubDate>Tue, 21 Feb 2017 23:56:58 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Do you want to try out Windows containers, but don't want to start too low level? If you are using one of the following programming languages you can benefit of already available official Docker images for Windows.&lt;/p&gt;
&lt;p&gt;These Docker images are well maintained and you can just start and put your application code inside and run your application easily in a Windows container.&lt;/p&gt;
&lt;p&gt;Someone else did the hard work how to install the runtime or compiler for language XYZ into Windows Server Core container or even a Nanoserver container.&lt;/p&gt;
&lt;h2 id="prefernanoserver"&gt;Prefer NanoServer&lt;/h2&gt;
&lt;p&gt;So starting to work with NanoServer is really easy with Docker as you only choose the right image for the &lt;code&gt;FROM&lt;/code&gt; instruction in your &lt;code&gt;Dockerfile&lt;/code&gt;. You can start with windowsservercore images, but I encourage you to test with nanoserver as well. For these languages it is easy to switch and the final Docker images are much smaller.&lt;/p&gt;
&lt;p&gt;So let's have a look which languages are already available. The corresponding Docker Hub page normally has a short intro how to use these Docker images.&lt;/p&gt;
&lt;h2 id="go"&gt;Go&lt;/h2&gt;
&lt;p&gt;The Go programming language is available on the Docker Hub as image &lt;a href="https://hub.docker.com/_/golang/"&gt;&lt;code&gt;golang&lt;/code&gt;&lt;/a&gt;. To get the latest Go 1.8 for either Windows Server Core or NanoServer you choose one of these.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FROM golang:windowsservercore&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FROM golang:nanoserver&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Have a look at the &lt;a href="https://hub.docker.com/_/golang/"&gt;tags page&lt;/a&gt; if you want another version or if you want to pin a specific version of Golang.&lt;/p&gt;
&lt;h2 id="java"&gt;Java&lt;/h2&gt;
&lt;p&gt;When you hear Java you might immediately think of Oracle Java. But searching for alternatives I found three OpenJDK distros for Windows. One of them recently made it into the official &lt;a href="https://hub.docker.com/_/openjdk/"&gt;&lt;code&gt;openjdk&lt;/code&gt;&lt;/a&gt; Docker images. Both Windows Server Core and NanoServer are supported.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FROM openjdk:windowsservercore&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FROM openjdk:nanoserver&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;If you prefer Oracle Java for private installations, you can build a Docker image with the Dockerfiles provided in the &lt;a href="https://github.com/oracle/docker-images/tree/master/OracleJava/windows-java-8"&gt;oracle/docker-images&lt;/a&gt; repository.&lt;/p&gt;
&lt;h2 id="nodejs"&gt;Node.JS&lt;/h2&gt;
&lt;p&gt;For Node.js there are pull requests awaiting a CI build agent for Windows to make it into the official &lt;a href="https://hub.docker.com/_/node/"&gt;&lt;code&gt;node&lt;/code&gt;&lt;/a&gt; images.&lt;/p&gt;
&lt;p&gt;In the meantime you can use one of my maintained images, for example the latest Node LTS version for both Windows Server Core and NanoServer:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FROM stefanscherer/node-windows:6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FROM stefanscherer/node-windows:6-nano&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;You also can find more tags and versions at the &lt;a href="https://hub.docker.com/r/stefanscherer/node-windows/"&gt;Docker Hub&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="python"&gt;Python&lt;/h2&gt;
&lt;p&gt;The script language Python is available as Windows Server Core Docker image at the official &lt;a href="https://hub.docker.com/_/python/"&gt;&lt;code&gt;python&lt;/code&gt;&lt;/a&gt; images. Both major versions of Python are available.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FROM python:3-windowsservercore&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FROM python:2-windowsservercore&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I also have a Python Docker image &lt;a href="https://hub.docker.com/r/stefanscherer/python-windows/"&gt;for NanoServer&lt;/a&gt; with Python 3.6 to create smaller Docker images.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FROM stefanscherer/python-windows:nano&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="netcore"&gt;.NET Core&lt;/h2&gt;
&lt;p&gt;Microsoft provides Linux and Windows Docker images for .NET Core at &lt;a href="https://hub.docker.com/r/microsoft/dotnet/"&gt;&lt;code&gt;microsoft/dotnet&lt;/code&gt;&lt;/a&gt;. For Windows it is NanoServer only, but this is no disadvantage as you should plan for the smaller NanoServer images.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FROM microsoft/dotnet:nanoserver&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="aspnet"&gt;&lt;a href="http://ASP.NET"&gt;ASP.NET&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For &lt;a href="http://ASP.NET"&gt;ASP.NET&lt;/a&gt; there are Windows Server Core Docker images for the major versions 3 and 4 with IIS installed at &lt;a href="https://hub.docker.com/r/microsoft/aspnet/"&gt;&lt;code&gt;microsoft/aspnet&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;FROM microsoft/aspnet:4.6.2-windowsservercore&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FROM microsoft/aspnet:3.5-windowsservercore&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The number of programming languages provided in Windows Docker images is growing. This makes it relatively easy to port Linux applications to Windows or use Docker images to distribute apps for both platforms.&lt;/p&gt;
&lt;p&gt;Haven't found an image for your language? Have I missed something? Please let me know, and use the comments below if you have questions how to get started. Thanks for your interest. You can follow me on Twitter &lt;a href="https://twitter.com/stefscherer"&gt;@stefscherer&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>How to build a Node.js Nano Server Docker base image</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Beginning with &lt;strong&gt;Windows 10 Insider&lt;/strong&gt; 14342 you can enable the new &lt;strong&gt;Containers feature&lt;/strong&gt; in Windows. This allows you to run Windows Containers directly in Windows 10 as Hyper-V containers. At the moment only NanoServer containers are supported. So it's time to get used to NanoServer and how to create some&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/how-to-build-nodejs-nanoserver-image/</link><guid isPermaLink="false">5986d4ec688a490001540967</guid><category>Docker</category><category>Nano Server</category><category>Windows 10</category><category>Node.js</category><dc:creator>Stefan Scherer</dc:creator><pubDate>Sun, 29 May 2016 18:00:53 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Beginning with &lt;strong&gt;Windows 10 Insider&lt;/strong&gt; 14342 you can enable the new &lt;strong&gt;Containers feature&lt;/strong&gt; in Windows. This allows you to run Windows Containers directly in Windows 10 as Hyper-V containers. At the moment only NanoServer containers are supported. So it's time to get used to NanoServer and how to create some base images.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/05/windows10-containers-feature.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;In this blog post I'll show how to build small base images to deploy Node.js applications as NanoServer Docker images that you can run &lt;a href="https://msdn.microsoft.com/en-us/virtualization/windowscontainers/quick_start/quick_start_windows_10"&gt;in Windows 10&lt;/a&gt; or in Windows Server 2016 TP5.&lt;/p&gt;
&lt;h2 id="whatisnanoserver"&gt;What is Nano Server?&lt;/h2&gt;
&lt;p&gt;Each Docker image must use of of the two OS images: &lt;code&gt;windowsservercore&lt;/code&gt; or &lt;code&gt;nanoserver&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;Windows Server Core&lt;/strong&gt; image is &lt;strong&gt;highly compatible&lt;/strong&gt; with previous Windows Server Core installations. You don't have a GUI, but you can install almost everything into it. But this compatibility comes with a prize, the size of the OS image is about 9.3 GByte as it contains about a whole server.&lt;/p&gt;
&lt;p&gt;A &lt;strong&gt;Nano Server&lt;/strong&gt; image is &lt;strong&gt;highly optimized&lt;/strong&gt; and almost everything was taken out of it to be able to deploy more of these containers in cloud servers. The size is about 817 MByte. This makes installing Docker on Windows 10 much faster than with the &lt;code&gt;windowsservercore&lt;/code&gt; OS image.&lt;/p&gt;
&lt;p&gt;So if you get asked which to choose you probably would answer to take the smaller one.&lt;/p&gt;
&lt;h2 id="thechallengemsipackages"&gt;The challenge: MSI packages&lt;/h2&gt;
&lt;p&gt;But as soon as you try to write a &lt;code&gt;Dockerfile&lt;/code&gt; to install some software into a Docker image you will notice that the minimized OS comes with a new challenge. &lt;strong&gt;You can't install MSI packages in Nano Server.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;If you look at &lt;a href="https://nodejs.org"&gt;nodejs.org&lt;/a&gt; there are only MSI packages for Windows if you also want to have npm installed.&lt;/p&gt;
&lt;p&gt;So how could we build a Node.js Docker image based on Nano Server? I've tried different ways, eg. also installing tools like lessmsi while building the Nano Server image only to find out that lessmsi is only a 32 bit application. Another restriction in Nano Server: &lt;strong&gt;You only can run 64 bit processes in Nano Server.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Another approach would be installing Node.js on your host machine and copying the files into the Docker image. But I don't want to install more tools than needed on a Docker host.&lt;/p&gt;
&lt;p&gt;Therefore I show you a way to use only Docker commands and a Windows Server 2016 TP5 machine to build both Windows Server Core image as well as a Nano Server image with Node.js + npm installed.&lt;/p&gt;
&lt;h3 id="step1installmsiintowindowsservercoreimage"&gt;Step 1 - Install MSI into Windows Server Core image&lt;/h3&gt;
&lt;p&gt;A much easier way is to start with a Windows Server Core image. You can download and install the Node.js MSI package with this &lt;code&gt;Dockerfile&lt;/code&gt;. This is very similar to the Linux version and downloads, verifies the download, installs the package and then removes the download again.&lt;/p&gt;
&lt;p&gt;Now open an editor with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;notepad Dockerfile.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and enter this &lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM windowsservercore

ENV NPM_CONFIG_LOGLEVEL info
ENV NODE_VERSION 4.4.5
ENV NODE_SHA256 7b2409605c871a40d60c187bd24f6f6ddf10590df060b7d905ef46b3b3aa7f81

RUN powershell -Command \
    wget -Uri https://nodejs.org/dist/v%NODE_VERSION%/node-v%NODE_VERSION%-x64.msi -OutFile node.msi -UseBasicParsing ; \
    if ((Get-FileHash node.msi -Algorithm sha256).Hash -ne $env:NODE_SHA256) {exit 1} ; \
    Start-Process -FilePath msiexec -ArgumentList /q, /i, node.msi -Wait ; \
    Remove-Item -Path node.msi

CMD [ &amp;quot;node.exe&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can build the Node.js Docker image with this command&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t node:4.4.5 .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After that you have Node.js + npm installed in this Docker image.&lt;/p&gt;
&lt;h3 id="step2distillnodejsfolder"&gt;Step 2 - Distill Node.js folder&lt;/h3&gt;
&lt;p&gt;Now we want to distill the Node.js folder from the Docker image. To do that we have to run a Docker container and then we can copy the folder to a temporary folder on the host machine.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --name=node-temp node:4.4.5 node --version
docker cp &amp;quot;node-temp:c:\Program Files\nodejs&amp;quot; nodejs
docker rm -vf node-temp
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="step3copydeploytonanoserverimage"&gt;Step 3 - COPY deploy to Nano Server image&lt;/h3&gt;
&lt;p&gt;With this extracted folder we build the Nano Server image. The following &lt;code&gt;Dockerfile&lt;/code&gt; copies the contents of that temporary folder into the Windows directory which is already in PATH. You may want to put the files in another directory, but then you also have to add it to the &lt;code&gt;PATH&lt;/code&gt; environment.&lt;/p&gt;
&lt;p&gt;Create a sub folder for the Nano Dockerfile&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir nano
notepad nano\Dockerfile.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and create this &lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM nanoserver

COPY nodejs /windows/system32

CMD [ &amp;quot;node.exe&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Run this command to build the Nano Server image&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t node:4.4.5-nano nano
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we have two Docker images, one for Windows Server Core and one for Nano Server.&lt;/p&gt;
&lt;p&gt;Here is a small diagram of the three steps we just did:&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2016/05/nodejs_nanoserver-2.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;I've uploaded both Docker images to the &lt;a href="https://hub.docker.com/r/stefanscherer/node-windows/tags/"&gt;Docker Hub&lt;/a&gt; and found out that the Windows Server Core image is about &lt;strong&gt;55 MByte&lt;/strong&gt; and the Nano Server image is only &lt;strong&gt;9 MByte&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Extracting all the layers of the first Docker image I found out that installing an MSI package also saves a copy of the package in the MSI cache. And running commands also leaves some changes in local databases and the registry which is also stored as difference in the layer.&lt;/p&gt;
&lt;p&gt;So one advice to build small Windows Docker images is to avoid installing MSI packages and prefer ZIP files or even using a COPY deployment into an image. Of course MSI packages are often more convenient to install but result in bigger image sizes.&lt;/p&gt;
&lt;h2 id="buildappwithonbuild"&gt;Build app with ONBUILD&lt;/h2&gt;
&lt;p&gt;Another easy way to dockerize your Node.js application is the &lt;code&gt;ONBUILD&lt;/code&gt; feature in the &lt;code&gt;Dockerfile&lt;/code&gt;. At least for simple examples it is very convenient to use a prepared Docker images with that feature.&lt;/p&gt;
&lt;p&gt;So let's build another &lt;code&gt;Dockerfile&lt;/code&gt; just like the official &lt;code&gt;node:onbuild&lt;/code&gt; image which does these steps to install your application and all the dependencies:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;copy package.json&lt;/li&gt;
&lt;li&gt;run npm install&lt;/li&gt;
&lt;li&gt;copy rest of sources&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So we create another folder for that &lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir nano\onbuild
notepad nano\onbuild\Dockerfile.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and the following content:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM node:4.4.5-nano

RUN mkdir \app
WORKDIR /app

ONBUILD COPY package.json package.json
ONBUILD RUN npm install
ONBUILD COPY . .

CMD [ &amp;quot;npm.cmd&amp;quot;, &amp;quot;start&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now build the Nano Server image with the ONBUILD feature:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build --isolation=hyperv -t node:4.4.5-nano-onbuild nano/onbuild
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I have tested this with a small Node.js web server that uses Express and some other dependencies.&lt;/p&gt;
&lt;p&gt;To build a dockerized Node.js application running in a Nano Server container you only have to go to your Node.js source code and add a single line &lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM nano:4.4.5-nano-onbuild
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and build your application Docker image with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build --isolation=hyperv -t mynodeapp:nano .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="optimizations"&gt;Optimizations&lt;/h2&gt;
&lt;p&gt;Investigating the layers of such an application showed some other temporary folders which aren't needed inside the Docker image.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A npm-cache folder&lt;/li&gt;
&lt;li&gt;Many files in temp folder, also from npm&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So we can optimize that ONBUILD &lt;code&gt;Dockerfile&lt;/code&gt; a little bit to remove these temp folders while building your application Docker image. There is a command &lt;code&gt;npm cache clean&lt;/code&gt;, but this didn't work for me, so I have changed that to some &lt;code&gt;rd&lt;/code&gt; commands. This is the final ONBUILD &lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-Dockerfile"&gt;FROM node:4.4.5-nano

RUN mkdir \app
WORKDIR /app

ONBUILD COPY package.json package.json
ONBUILD RUN npm install &amp;amp; rd /s /q %APPDATA%\npm-cache &amp;amp; for /d %G in (&amp;quot;%TEMP%\npm-*&amp;quot;) do rd /s /q &amp;quot;%~G&amp;quot;
ONBUILD COPY . .

CMD [ &amp;quot;npm.cmd&amp;quot;, &amp;quot;start&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;With that optimized Docker image deploying a simple Express web server the &lt;a href="https://hub.docker.com/r/stefanscherer/hello-dresden/tags/"&gt;final application Docker image&lt;/a&gt; went down from &lt;strong&gt;24 MByte&lt;/strong&gt; to &lt;strong&gt;15 MByte&lt;/strong&gt;. In comparison with the unoptimized Windows Server Core image the same application is &lt;strong&gt;82 MByte&lt;/strong&gt; on the Docker Hub.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;If you don't want to build these Node.js Docker images manually you can find them on the &lt;a href="https://hub.docker.com/r/stefanscherer/node-windows/"&gt;Docker Hub&lt;/a&gt; with links to the Dockerfiles in the &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/tree/master/node"&gt;GitHub repo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;With such a Node.js Nano Server base image on the Docker Hub you can start developing on your Windows 10 machine. Now dockerize your Node.js apps into Nano Server containers and share them with others via the Docker Hub.&lt;/p&gt;
&lt;p&gt;The Windows Server 2016 is only needed to install MSI packages and distill the software into Nano Server images.&lt;/p&gt;
&lt;p&gt;If you find this blog post useful, just share it with your friends and colleages. Please leave a comment if you have questions or improvements. You can follow me on Twitter &lt;a href="https://twitter.com/stefscherer"&gt;@stefscherer&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item><item><title>Create a Node.js Container image for Windows</title><description>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Last week Microsoft has released a technical preview of the upcoming Windows Server 2016 with a first running version of the Docker daemon for Windows.&lt;/p&gt;
&lt;p&gt;So everybody who is interested in Docker on Windows is now able to get a first impression of the current work. You either need a&lt;/p&gt;&lt;/div&gt;</description><link>http://localhost:2368/create-an-io-js-container-image-for-windows/</link><guid isPermaLink="false">5986d4ec688a49000154095b</guid><category>Docker</category><category>Windows</category><category>Node.js</category><dc:creator>Stefan Scherer</dc:creator><pubDate>Sun, 23 Aug 2015 18:36:00 GMT</pubDate><content:encoded>&lt;div class="kg-card-markdown"&gt;&lt;p&gt;Last week Microsoft has released a technical preview of the upcoming Windows Server 2016 with a first running version of the Docker daemon for Windows.&lt;/p&gt;
&lt;p&gt;So everybody who is interested in Docker on Windows is now able to get a first impression of the current work. You either need a VM running in Azure with Windows 2016 TP3 or you &lt;a href="http://www.microsoft.com/en-us/evalcenter/evaluate-windows-server-technical-preview"&gt;try Windows 2016 TP3&lt;/a&gt; locally in a VM.&lt;/p&gt;
&lt;h2 id="setupdockeronwindows"&gt;Setup Docker on Windows&lt;/h2&gt;
&lt;p&gt;In the case you only have a vanilla Window 2016 TP3 machine without Docker installed, you can follow this &lt;a href="https://msdn.microsoft.com/virtualization/windowscontainers/quick_start/inplace_setup"&gt;Quick start guide&lt;/a&gt;. Open a Powershell as an administrator and run these commands:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;wget -uri http://aka.ms/setupcontainers -OutFile C:\ContainerSetup.ps1
C:\ContainerSetup.ps1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This script will download and install the Docker daemon and a base image. Now the Docker daemon should be up and running as well as a first Docker base image &lt;code&gt;windowsservercore&lt;/code&gt;. You can check that you are working with a Windows Docker daemon with the command &lt;code&gt;docker version&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/08/docker-version-png-shadow.png" alt=""&gt;&lt;/p&gt;
&lt;h2 id="thefirstownwindowsdockerimage"&gt;The first own Windows Docker image&lt;/h2&gt;
&lt;p&gt;As a first example I want to show how to create a Node.js Docker image for Windows. I started with the &lt;a href="https://github.com/nodejs/docker-iojs/blob/662d803695a66cc3f01687bdca93ef23f416d030/3.1/Dockerfile"&gt;official iojs Dockerfile&lt;/a&gt; and ported that to Windows commands. There are three steps to do:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;download the Node.js package&lt;/li&gt;
&lt;li&gt;install the package&lt;/li&gt;
&lt;li&gt;use the interpreter as the CMD&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This is &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/blob/a99efe07160bd7f5ba62dcefa55e3c64a1bb2dcd/iojs/3.2/Dockerfile"&gt;my Windows version&lt;/a&gt; of the &lt;code&gt;Dockerfile&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM windowsservercore

ENV NPM_CONFIG_LOGLEVEL info
ENV IOJS_VERSION 3.2.0

RUN powershell -Command &amp;quot;wget -Uri https://iojs.org/dist/v%IOJS_VERSION%/iojs-v%IOJS_VERSION%-x64.msi -OutFile iojs.msi -UseBasicParsing&amp;quot;

RUN msiexec.exe /q /i iojs.msi

CMD [ &amp;quot;iojs&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;To try it yourself, open up an editor and put these lines into a file &lt;code&gt;Dockerfile&lt;/code&gt; and save it. Then build the Docker image with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t iojs .
docker tag iojs:latest iojs:3.2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now you have your own iojs Docker image for Windows. The second command also tags the &lt;code&gt;iojs:latest&lt;/code&gt; with the version number of io.js. You can check your available images with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker images
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can check the Docker image by running the installed Node.js runtime and retrieve the iojs version&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;PS C:\Users\vagrant&amp;gt; docker run -it iojs iojs --version
v3.2.0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;OK, we now have the latest io.js running in a Windows Docker container.&lt;/p&gt;
&lt;h2 id="createaniojsonbuilddockerimage"&gt;Create an iojs:onbuild Docker image&lt;/h2&gt;
&lt;p&gt;The official iojs Docker image has a nice second Dockerfile that uses the &lt;code&gt;ONBUILD&lt;/code&gt; keyword. This Dockerfile can be used to add your Node.js application into a new Docker image very easily. You do not need to have Node.js installed on your host.&lt;/p&gt;
&lt;p&gt;Again I started with the &lt;a href="https://github.com/nodejs/docker-iojs/blob/662d803695a66cc3f01687bdca93ef23f416d030/3.1/onbuild/Dockerfile"&gt;official iojs:onbuild Dockerfile&lt;/a&gt; and ported it to Windows.&lt;/p&gt;
&lt;p&gt;This is the Linux version of the Dockerfile:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM iojs:3.1.0

RUN mkdir -p /usr/src/app
WORKDIR /usr/src/app

ONBUILD COPY package.json /usr/src/app/
ONBUILD RUN npm install
ONBUILD COPY . /usr/src/app

CMD [ &amp;quot;npm&amp;quot;, &amp;quot;start&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;It uses &lt;code&gt;WORKDIR&lt;/code&gt; to set the current directory for all further commands. On Windows this and the &lt;code&gt;COPY&lt;/code&gt; commands seems to be a work in progress. The current behavior is slightly different to Linux containers, but I found a workaround.&lt;/p&gt;
&lt;p&gt;This is &lt;a href="https://github.com/StefanScherer/dockerfiles-windows/blob/a99efe07160bd7f5ba62dcefa55e3c64a1bb2dcd/iojs/3.2/onbuild/Dockerfile"&gt;my current Windows version&lt;/a&gt; of the onbuild Dockerfile that works with the current version of the Windows docker daemon.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM iojs:3.2.0

RUN mkdir \app
WORKDIR /app

ONBUILD COPY package.json package.json
ONBUILD RUN npm install
ONBUILD COPY . .

CMD [ &amp;quot;npm.cmd&amp;quot;, &amp;quot;start&amp;quot; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now create the Docker image for this Dockerfile with this command:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t iojs:onbuild .
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="putyournodejsappintoacontainer"&gt;Put your Node.js app into a Container&lt;/h2&gt;
&lt;p&gt;Now we create a simple Node.js application and create a Windows Docker image with it. We now create three files&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;package.json - with the start command and optional dependencies&lt;/li&gt;
&lt;li&gt;index.js - with the application source code&lt;/li&gt;
&lt;li&gt;Dockerfile - to build the Docker image&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="packagejson"&gt;package.json&lt;/h3&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;hello-node&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;0.0.1&amp;quot;,
  &amp;quot;description&amp;quot;: &amp;quot;Hello world from io.js in a Windows docker container&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;scripts&amp;quot;: {
    &amp;quot;start&amp;quot;: &amp;quot;node index.js&amp;quot;,
    &amp;quot;test&amp;quot;: &amp;quot;echo \&amp;quot;Error: no test specified\&amp;quot; &amp;amp; exit 1&amp;quot;
  },
  &amp;quot;author&amp;quot;: &amp;quot;Stefan Scherer&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="indexjs"&gt;index.js&lt;/h3&gt;
&lt;p&gt;As a simple example we just print a message, wait five seconds and print another message and exit the Node.js application.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;'use strict';

const os = require('os');

console.log('Hello World from', os.hostname());

setTimeout(function () {
  console.log('Bye bye!');
}, 5*1000);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="dockerfile"&gt;Dockerfile&lt;/h3&gt;
&lt;p&gt;The &lt;code&gt;Dockerfile&lt;/code&gt; for this example is quite simple. It just uses the Windows version of the &lt;code&gt;iojs:onbuild&lt;/code&gt; Docker image:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;FROM iojs:onbuild
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;All further steps to add the Node.js code and run &lt;code&gt;npm install&lt;/code&gt; is already in this Docker image. We now install the Node.js application and create a new Container image with name &lt;code&gt;hello-node&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker build -t hello-node .
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/08/docker-build-png-shadow.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;Now run the application with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run -t hello-node
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You also can run the container in detached mode with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker run --name=hello -d hello-node 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;and check the output while running the container or afterwards with&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;docker logs hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src="http://localhost:2368/content/images/2015/08/docker-run-png-shadow.png" alt=""&gt;&lt;/p&gt;
&lt;p&gt;So as you can see it is amazing what is already possible with Docker on Windows. I hope you enjoyed this blog post. Please feel free to add comments below and share this post if you like.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The technical preview gives us the possibility to get in touch with Docker for Windows for the first time. There may be some rough edges here and there, but I think there will be a fast progress to run Docker on Windows as smooth as with Linux containers.&lt;/p&gt;
&lt;/div&gt;</content:encoded></item></channel></rss></html>